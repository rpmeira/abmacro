[
  {
    "path": "posts/2021-02-09-externrede/",
    "title": "Modelo - Externalidades de Rede",
    "description": "Este post apresenta uma versão em LSD do modelo de externalidades de rede proposto por Brian Arthur.",
    "author": [
      {
        "name": "Rafael Peixoto",
        "url": {}
      }
    ],
    "date": "2021-02-09",
    "categories": [
      "Modelos",
      "LSD"
    ],
    "contents": "\r\n\r\nContents\r\nIntrodução\r\nModelo\r\nEquações\r\nConclusão\r\n\r\nIntrodução\r\nO modelo de externalidades de rede proposto por Brian Arthur explora a dinâmica de alocação sob retornos crescentes, em um contexto no qual agentes escolhem entre tecnologias que competem entre si para serem adotadas. Quando duas ou mais tecnologias, com retornos crescentes, competem por um mercado de consumidores em potencial, eventos aleatórios podem, por mero acaso, dar uma vantagem inicial para uma delas. Com isso, essa tecnologia passa a ser mais adotada, o que pode fazer com que ela seja mais aperfeiçoada e, como consequência, adotada por mais consumidores ainda. Dessa forma, uma tecnologia que, por acaso, ganhe uma liderança inicial em adoções, pode dominar o mercado, bloqueando — locking out — o crescimento das demais.\r\nIsso ocorre, de acordo com Brian Arthur, pois os consumidores valorizam um produto (ou tecnologia) por dois motivos:\r\nSuas próprias preferências pessoais (como pressuposto na teoria econômica clássica)\r\nExternalidades de rede, ou seja, a qualidade adicionada a um produto devido ao fato de outros agentes o usarem.\r\nA partir disso, o modelo proposto por Arthur busca examinar explicitamente os efeitos, sobre a dinâmica da adoção de uma tecnologia (ou escolha de um produto), das externalidades de rede.\r\nModelo\r\nO modelo aqui discutido considera dois grupos de consumidores, tipo 0 e tipo 1, e dois tipos de produtos, MS e Apple. Um consumidor avalia um produto atribuindo a ele uma utilidade composta por dois elementos:\r\nA própria preferência do consumidor\r\nO valor de rede do produto\r\nAs preferências dos consumidores são fixas, embora divergindo para cada um dos grupos de consumidores e tipos de produto. O valor de rede, por sua vez, muda com o número de outros usuários usando o tipo de produto em questão.\r\nA partir dessas definições, vamos expressar formalmente a utilidade dos consumidores. Sejam \\(v^{MS}_0\\) e \\(v^{Apple}_0\\) as preferências próprias do consumidor tipo 0 para os produtos MS e Apple. Adicionalmente, sejam \\(N^{MS}\\) e \\(N^{Apple}\\) os números de outros consumidores que utilizam cada um desses produtos respectivamente. Por fim, seja \\(x_0\\) o efeito da externalidade de rede para o consumidor do tipo 0. O mesmo é feito para o consumidor tipo 1:\r\nTipo 0\r\n\\(U^{MS}_0 = v^{MS}_0 + x_0 \\times N^{MS}\\), escolhendo MS\r\n\\(U^{Apple}_0 = v^{Apple}_0 + x_0 \\times N^{Apple}\\), escolhendo Apple\r\nTipo 1\r\n\\(U^{MS}_1 = v^{MS}_1 + x_1 \\times N^{MS}\\), escolhendo MS\r\n\\(U^{Apple}_1 = v^{Apple}_1 + x_1 \\times N^{Apple}\\), escolhendo Apple\r\nCom isso, quando um agente precisa escolher qual produto comprar, MS ou Apple, ele simplesmente compara as utilidades:\r\nTipo 0\r\nEscolhe MS se \\(U_0^{MS} > U_0^{Apple}\\)\r\nEscolhe Apple se \\(U_0^{MS} < U_0^{Apple}\\)\r\nTipo 1\r\nEscolhe MS se \\(U_1^{MS} > U_1^{Apple}\\)\r\nEscolhe Apple se \\(U_1^{MS} < U_1^{Apple}\\)\r\n\r\nO modelo funciona da seguinte maneira:\r\nCrie aleatoriamente, com 50% de probabilidade para cada, um agente do tipo 0 ou 1.\r\nCompute suas utilidades ao escolher MS ou Apple.\r\nEscolha, para esse novo agente, o produto com a maior utilidade.\r\nAtualize o \\(N^{MS}\\) caso o agente escolha MS ou o \\(N^{Apple}\\) caso ele escolha Apple.\r\nEquações\r\nA equações requeridas para rodar o modelo derivam dos itens apontados acima (sobre como o modelo funciona), sendo necessário, todavia, uma equação (tanto para utilidade, quanto para número consumidores e sua consequente participação de mercado) para cada tipo de produto. O modelo inteiro é constituido, assim, por 7 equações:\r\n//#define EIGENLIB          // uncomment to use Eigen linear algebra library\r\n//#define NO_POINTER_INIT   // uncomment to disable pointer checking\r\n#include \"fun_head_fast.h\"\r\n// do not add Equations in this area\r\nMODELBEGIN\r\n// insert your equations here, between the MODELBEGIN and MODELEND words\r\n\r\nEQUATION(\"NewAgent\")\r\n/*\r\nType of new agent\r\n*/\r\nif(RND < 0.5)\r\n    v[0] = 1;\r\nelse\r\n    v[0] = 0;\r\nRESULT(v[0])\r\n\r\n\r\nEQUATION(\"UtilityMS\")\r\n/*\r\nUtility in using MS\r\n*/\r\nv[0] = V(\"NewAgent\"); // type of new agent\r\nif(v[0] == 0)\r\n    {\r\n    v[1] = V(\"User0MS\"); // value for agent type 0 using MS\r\n    v[2] = V(\"User0Net\"); // network externalitie coefficiente for agent type 0\r\n    }\r\nelse\r\n    {\r\n    v[1] = V(\"User1MS\"); // value for agent type 1 using MS\r\n    v[2] = V(\"User1Net\"); // network externalitie coefficiente for agent type 1\r\n    }\r\nv[3] = VL(\"NumMS\", 1); // number of existing consumers using MS\r\nv[4] = v[1] + (v[2] * v[3])\r\nRESULT(v[4])\r\n\r\n\r\nEQUATION(\"UtilityApple\")\r\n/*\r\nUtility in using Apple\r\n*/\r\nv[0] = V(\"NewAgent\"); // type of new agent\r\nif(v[0] == 0)\r\n    {\r\n    v[1] = V(\"User0Apple\"); // value for agent type 0 using Apple\r\n    v[2] = V(\"User0Net\"); // network externalitie coefficiente for agent type 0\r\n    }\r\nelse\r\n    {\r\n    v[1] = V(\"User1Apple\"); // value for agent type 1 using Apple\r\n    v[2] = V(\"User1Net\"); // network externalitie coefficiente for agent type 1\r\n    }\r\nv[3] = VL(\"NumApple\", 1); // number of existing consumers using Apple\r\nv[4] = v[1] + (v[2] * v[3])\r\nRESULT(v[4])\r\n\r\n\r\nEQUATION(\"NumMS\")\r\n/*\r\nNumber of MS users\r\n*/\r\nv[0] = VL(\"NumMS\", 1);\r\nv[1] = V(\"UtilityApple\");\r\nv[2] = V(\"UtilityMS\");\r\nif(v[2] > v[1])\r\n    v[3] = v[0] + 1;\r\nelse\r\n    v[3] = v[0];\r\nRESULT(v[3])\r\n\r\n\r\nEQUATION(\"NumApple\")\r\n/*\r\nNumber of Apple users\r\n*/\r\nv[0] = VL(\"NumApple\", 1);\r\nv[1] = V(\"UtilityApple\");\r\nv[2] = V(\"UtilityMS\");\r\nif(v[2] < v[1])\r\n    v[3] = v[0] + 1;\r\nelse\r\n    v[3] = v[0];\r\nRESULT(v[3])\r\n\r\n\r\nEQUATION(\"ShareMS\")\r\n/*\r\nShare of MS users\r\n*/\r\nv[0] = V(\"NumMS\");\r\nv[1] = V(\"NumApple\");\r\nv[2] = v[0] / (v[0] + v[1])\r\nRESULT(v[2])\r\n\r\n\r\nEQUATION(\"ShareApple\")\r\n/*\r\nShare of Apple users\r\n*/\r\nv[0] = V(\"NumMS\");\r\nv[1] = V(\"NumApple\");\r\nv[2] = v[1] / (v[0] + v[1])\r\nRESULT(v[2])\r\n\r\n\r\nMODELEND\r\n// do not add Equations in this area\r\nvoid close_sim( void )\r\n{\r\n    // close simulation special commands go here\r\n}\r\nVamos analisar cada um dessas equações com mais detalhes. Lembrando que os modelos escritos no LSD são compostos por um conjunto de Equações que são atualizadas em cada período de uma simulação. Essas equações descrevem o comportamento das variáveis que fazem parte do modelo.\r\nEQUATION(“NewAgent”)\r\nA primeira equação do modelo (lembrando que no LSD a ordem das equações não importa) é bem simples e serve para decidir, com probabilidade de 50%, o tipo de agente, tipo 0 ou tipo 1. Em cada período de tempo (da simulação), a variável “NewAgent” assume o valor 0 ou 1, com probabilidade de 50% para cada.\r\nEQUATION(\"NewAgent\")\r\n/*\r\nType of new agent\r\n*/\r\nif(RND < 0.5)\r\n    v[0] = 1;\r\nelse\r\n    v[0] = 0;\r\nRESULT(v[0])\r\nPor exemplo, seja uma simulação com 50 períodos, a variável “NewAgent” apresenta o seguinte comportamento:\r\n\r\n\r\n\r\nEQUATION(“UtilityMS”) | EQUATION(“UtilityApple”)\r\nAs proximas duas equações servem para calcular a utilidade de cada produto (MS e Apple). Como mencionado anteriormente, essa utilidade depende das preferências individuais dos consumidores (tipo 0 e tipo 1) e das externalidades de rede, que por sua vez dependem do número de usuários de cada produto. Ou seja, \\(U^{i}_j = v^{i}_j + x_j \\times N^{i}\\), onde \\(i\\) pode ser \\(MS\\) ou \\(Apple\\) e \\(j\\) pode ser 0 ou 1.\r\n\\(v^{i}_j\\) é um parâmetro que pode assumir 4 valores, a depender do tipo de consumidor e do tipo de produto.\r\n\\(x_j\\) é um parâmetro que pode assumir 2 valores, a depender do tipo de consumidor.\r\n\\(N^{i}\\) é uma variável que conta a quandidade de consumidores de cda tipo de produto.\r\nNo código abaixo, que calcula a utilidade de MS em cada período (seja o novo consumidor sendo do tipo 0 sendo do tipo 1), \\(v^{MS}_0\\) é representado pelo parâmetro “User0MS” e \\(x_0\\) é representado por “User0Net”. O mesmo ocorre para oa parâmetros do consumidor tipo 1.\r\nEQUATION(\"UtilityMS\")\r\n/*\r\nUtility in using MS\r\n*/\r\nv[0] = V(\"NewAgent\"); // type of new agent\r\nif(v[0] == 0)\r\n    {\r\n    v[1] = V(\"User0MS\"); // value for agent type 0 using MS\r\n    v[2] = V(\"User0Net\"); // network externalitie coefficiente for agent type 0\r\n    }\r\nelse\r\n    {\r\n    v[1] = V(\"User1MS\"); // value for agent type 1 using MS\r\n    v[2] = V(\"User1Net\"); // network externalitie coefficiente for agent type 1\r\n    }\r\nv[3] = VL(\"NumMS\", 1); // number of existing consumers using MS\r\nv[4] = v[1] + (v[2] * v[3])\r\nRESULT(v[4])\r\nPor exemplo, digamos que os parâmetros sejam escolhidos com os seguintes valores:\r\n\\(v^{MS}_0 = 10\\)\r\n\\(v^{MS}_1 = 5\\)\r\n\\(v^{Apple}_0 = 5\\)\r\n\\(v^{Apple}_1 = 10\\)\r\nOu seja, consumidores tipo 0 dão 5 de utilidade para MS e 10 para Apple, e consumidores tipo 1 fazem o contrário, dão 10 de utilidade para MS e 5 para Apple. Além disso, digamos que tanto \\(x_0\\) quanto \\(x_1\\) possuam um valor de \\(0.2\\), ou seja, essa é a influência que cada número adicional de consumidores possui sobre a externalidade de rede tanto para consumidores do tipo 0 quanto para do tipo 1. Vejamo a evolução das variáveis “UtilityMS” e “UtilityApple”, conforme novos agentes vão aparecendo e escolhendo entre um produto e outro.\r\n\r\nt\r\nNewAgent\r\nUtilityApple\r\nUtilityMS\r\n1\r\n0\r\n5.0\r\n10.0\r\n2\r\n0\r\n5.0\r\n10.2\r\n3\r\n1\r\n10.0\r\n5.4\r\n4\r\n0\r\n5.2\r\n10.4\r\n5\r\n1\r\n10.2\r\n5.6\r\n6\r\n1\r\n10.4\r\n5.6\r\n7\r\n1\r\n10.6\r\n5.6\r\n8\r\n0\r\n5.8\r\n10.6\r\n9\r\n0\r\n5.8\r\n10.8\r\n10\r\n0\r\n5.8\r\n11.0\r\n\r\nComo visto na tabela, o primeiro agente foi do tipo 0, que atribui utilidade 10 para MS e 5 para Apple. Como 10 > 5, esse agente escolhe MS. O segundo agente também é do tipo 0 e atribui 10 para MS e 5 para Apple, porém como já há 1 consumidor utilizando MS, e a externalidade de rede é \\(x \\times N = 0.2 \\times 1 = 0.2\\), a utilidade total de MS é 10.2. O terceiro agente é do tipo 1, que atribui 5 para MS e 10 para Apple. Nesse terceiro períoro já há 2 agentes utilizando MS, portanto a utilidade de MS é acrescida de 0.4. De toda forma, porém, 10 > 5.4, e esse agente escolhe Apple. No longo prazo essas variáveis evoluem da seguinte forma:\r\n\r\n\r\n\r\nÉ possívle observar que após um certo período (em torno de \\(t=250\\)) a utilidade de apple sempre será maior que a de MS, independente do tipo de agente que entrará em seguida. Isso por que a externalidade de rede ultrapassa a diferença de preferências próprias entre os tipos de agentes. A partir desse ponto, todo novo agente irá escolher Apple, o que faz com que o número de usuários desse produto cresça continuamente, enquanto o número de usuários MS permaneça constante (a sua curva de utilidade irá alternar entre os valores 10 e 5 acrescidos da externalidade derivada do número de agentes que escolheram MS até o ponto em que a utilidade MS ultrapassava a de Apple a depender do tipo do agente).\r\nEQUATION(“NumMS”) | EQUATION(“NumApple”)\r\nA equação do número de usuários de cada produto simplemente compara os valores das utilidades de MS e Apple, calculadas nas equações mostradas anteriormente, e aumenta em uma unidade o valor do número de usuários a depender de qual utilidade é maior.\r\nEQUATION(\"NumMS\")\r\n/*\r\nNumber of MS users\r\n*/\r\nv[0] = VL(\"NumMS\", 1);\r\nv[1] = V(\"UtilityApple\");\r\nv[2] = V(\"UtilityMS\");\r\nif(v[2] > v[1])\r\n    v[3] = v[0] + 1;\r\nelse\r\n    v[3] = v[0];\r\nRESULT(v[3])\r\nA sua evolução é semelhante à da utilidade, dadas que ambas incrementam quando há uma adição de um agente nesse produto em específico. Recapitulando, em cada período surge um novo agente que deve escolher entre MS e Apple; para fazer tal escolha, esse agente compara as utilidades desses dois tipos de produtos. Além disso, há dois tipos de agentes, que atribuem valores diferentes para sua preferência individual entre MS e Apple. Assim, em cada período, cada novo agente computa as utilidades dos dois produtos — a partir da sua preferência individual e da externalidade de rede, que depende do número de usuários em cada produto — e escolhe o produto com maior utilidade. Com isso, vai aumentando o número de usuários de cada produto.\r\n\r\n\r\n\r\nEQUATION(“ShareMS”) | EQUATION(“ShareApple”)\r\nPor fim, é computado também o market share dos dois tipos de produtos, o que é feito apenas dividindo o número de usuários de cada produto pelo número total de agentes.\r\nEQUATION(\"ShareMS\")\r\n/*\r\nShare of MS users\r\n*/\r\nv[0] = V(\"NumMS\");\r\nv[1] = V(\"NumApple\");\r\nv[2] = v[0] / (v[0] + v[1])\r\nRESULT(v[2])\r\n\r\n\r\n\r\nConclusão\r\nEsse modelo explora a dinâmica de um mercado com dois produtos em competição, onde cada usuário adicional de um dos produtos aumenta a externalidade de rede desse produto. Como visto, após certo período o mercado é dominado por um dos tipos de produto e todo usuário novo passa a escolher esse produto, bloqueado — locking out — o outro. Para entender melhor o modelo, foi muito útil analisar as equações de forma separada, buscando observar os inputs que cada equação recebe (parâmetros e outras variáveis) e os outputs que ela retorna em cada período de tempo (os possíveis valores da variável em questão).\r\n\r\n\r\n\r\nARTHUR, W. B. Competing technologies, increasing returns, and lock-in by historical events. The economic journal, v. 99, n. 394, p. 116–131, 1989. \r\n\r\n\r\n\r\n\r\n",
    "preview": "posts/2021-02-09-externrede/externrede_files/figure-html5/unnamed-chunk-5-1.png",
    "last_modified": "2021-02-09T22:06:48-03:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "posts/2021-01-13-lsdmacro/",
    "title": "LSD Linguagem Macro",
    "description": "Este Post apresenta um breve resumo da linguagem macro do LSD, descrita no manual que acompanha o software.",
    "author": [
      {
        "name": "Rafael Peixoto",
        "url": {}
      }
    ],
    "date": "2021-01-21",
    "categories": [
      "Introdução",
      "LSD"
    ],
    "contents": "\r\n\r\nContents\r\nEstrutura do arquivo de Equação\r\nEQUATION(“variável”)\r\nArmazenamento temporário: v[n]\r\nObjetos e Ponteiros\r\nSufixos e famílias Macro\r\nFunções matemáticas e estatísticas\r\nCódigo C++ básico\r\n\r\nEstrutura do arquivo de Equação\r\nOs modelos escritos no LSD são compostos por um conjunto de Equações que são atualizadas em cada período de uma simulação. Essas equações descrevem o comportamento das variáveis que fazem parte do modelo. Os cógidos para cada Equação são separados um do outro, em blocos.\r\nA estrutura mínima de um modelo do LSD é a seguinte:\r\n#include \"../src/fun_head_fast.h\"\r\n\r\nMODELBEGIN\r\n\r\nMODELEND\r\n\r\nvoid close_sim( )  \r\n{  \r\n}\r\nAs equações do modelo devem ser inseridas entre \\(MODELBEGIN\\) e \\(MODELEND\\).\r\nCada variável do modelo possui sua própria Equação, e essa pode ser executada diversas vezes, a depender da quantidade de objetos (agentes) que a chamam. As variáveis e os parâmetros são localizadas dentro dos objetos, portanto cada objeto, ou cópia do objeto, possui uma cópia diferente das variáveis e dos parâmetros. Por exemplo, suponha um objeto, chamado \\(Firma\\), que contém a variável chamada \\(Q\\) que depende de outra variável chamda \\(K\\). Se são criadas diversas cópias do objeto \\(Firma\\), cada cópia da Equação para \\(Q\\), que necessita da variável \\(K\\) para seu cálculo, utilizará sua própria cópia de \\(K\\), ou seja a cópia de \\(K\\) contida no mesmo objeto que a cópia da Equação para \\(Q\\) que está sendo computada.\r\nA ordem com que as Equações aparecem no arquivo de Equação é irrelevante, uma vez que o LSD avalia de forma automática a sequencia de variáveis que será executada, com base nos períodos \\(t\\) dessa variáveis — Cada variável, e sua Equação associada, deve ser pensada como uma equação em diferença:\r\n\\[\r\n\\begin{aligned}\r\nX_t = f(Y_{t-lag}, Z_{t-lag}, \\dots)\r\n\\end{aligned}\r\n\\]\r\nAs Equações podem ser compostas também por parâmetros que, na maioria das vezes, são constantes durante as simulações — a menos que sejam modificados por outras variáveis, o que é possível por meio dos macros \\(WRITE(\\dots)\\) ou \\(INCR(\\dots)\\).\r\nEQUATION(“variável”)\r\nA macro \\(EQUATION\\) inicia um bloco de código associado a uma variável. Por exemplo:\r\nEQUATION( \"X\" )  \r\n/*\r\nComentário especificando o que a equação faz  \r\n*/ \r\n\r\nRESULT( 3 ) // Neste exemplo a equação sempre retorna o valor 3 para a variável X\r\nA primeira linha indica que o código se refere à variável X. A última linha indica o resultado que será atribuído para essa variável em cada período de tempo. No exemplo acima, é atriuído um valor constante para a variável, mas usulmente esse não é o caso. Esse resultado dependerá dos cálculos feitos pela Equação. O LSD oferece diversas macros para esses cálculos. Ao longo desse texto, serão vistas as macros mais frequentemente utilizadas.\r\nA macro mais utilizada é a \\(V(\\dots)\\), que simplesmente computa ou recupera o valor de alguma variável, parâmetro ou função do modelo. Por exemplo:\r\nEQUATION( \"PROF\" )  \r\n/***************************  \r\nA equação computa a taxa de lucro:\r\nPROF(t) = P(t) * A(t-1) - C - RIM – RIN * Inn  \r\nlucros por unidade de capital são iguais ao preço corrente vezes a produtividade no período anterior\r\nmenos o custo para pesquisa (firmas inovativas gastam para os dois tipos de pesquisa) e custos fixos.  \r\n***************************/\r\nRESULT( V(\"Price\") * VL(\"A\", 1) - V(\"C\") - V(\"RIM\") - V(\"RIN\") * V(\"Inn\") )\r\nArmazenamento temporário: v[n]\r\nO modo padrão de expressar a Equação é coletando um conjunto de dados gerados pelo modelo (variáveis e parâmetros) e elaborar em cima disso para chegar no resultado desejado para o valor da variável. v[n] fornece uma forma de armazenar valores temporários que serão utilizados pela Equação. Estão disponíveis até mil posições para v[n], para cada Equação: de v[0] a v[999]. Os valores de v[n] são redefinidos para cada Equação, portanto não podem ser utilizados para transferir informação de uma Equação para outra. ou entre periodos de tempo diferentes na mesma Equação. Exemplo:\r\nEQUATION( \"PROF\" )  \r\n/***************************  \r\nA equação computa a taxa de lucro:  \r\nPROF(t) = P(t) * A(t-1) - C - RIM – RIN * Inn    \r\nlucros por unidade de capital são iguais ao preço corrente vezes a produtividade no período anterior\r\nmenos o custo para pesquisa (firmas inovativas gastam para os dois tipos de pesquisa) e custos fixos.  \r\n***************************/\r\nv[0] = V( \"Price\" );  \r\nv[1] = VL( \"A\", 1 );  \r\nv[2] = V( \"C\" );  \r\nv[3] = V( \"RIM\" );  \r\nv[4] = V( \"RIN\" );  \r\nv[5] = V( \"Inn\" );  \r\n\r\nRESULT( v[0] * v[1] - v[2] - v[3] - v[4] * v[5] )\r\nExistem varias vantagens em utilizar v[n]: i) o código fica mais fácil de ler; ii) os valores intermediários podem ser observados usando o LSD Debugger; iii) se um valor é usado muitas vezes na mesma Equação, é mais rápido e menos propenso a erro guardar esse valor em um v[n].\r\nObjetos e Ponteiros\r\nA maioria das macros do LSD são operados dentro de um objeto, que é definido pelo ponteiro \\(p\\). As macros são operadas nos objetos para que uma mesma Equação possa ser reusada por diversas cópias do objeto. Por exemplo, seja um modelo com um objeto chamado Firma, que contém as variáveis Lucro, Preço e Quantidade, sendo que a Equação para o Lucro é:\r\n\\[\r\nLucro = Preço \\times Quantidade\r\n\\]\r\nO modelo pode possuir diversas cópias do objeto Firma, com cada uma tendo a sua própria cópia das variáveis Lucro, Preço e Quantidade. Ou seja, cada cópia do objeto Firma pode possuir trajetórias distintas para os valores dessas variáveis. O LSD toma conta dessa correspondência entre objetos e variáveis através dos seguintes meios:\r\n\\(p\\) se refere ao objeto que contém a variável cuja Equação está sendo computada.\r\n\\(c\\) se refere ao objeto que requisitou a computação da variável.\r\n\\(cur\\), \\(cur1\\), \\(cur2\\), etc., são ponteiros temporários que podem guardar os endereços correntes dos objetos obtidos de outras macros.\r\ncur\r\nDe forma um pouco mais detalhada, \\(cur\\) funciona de maneira semelhante a v[n], porém para ponteiros, ao invés de para valores numéricos. Assim como v[n] vai de v[0] a v[999], \\(cur\\) vai de \\(cur1\\) a \\(cur9\\). O usuário chama macros do LSD que retornam objetos e associam esses a \\(cur1\\), \\(cur2\\), \\(\\dots\\) e, com isso, usam esses ponteiros em outras macros que requeiram obejetos em seus cálculos.\r\nHOOK(…)\r\nQualquer objeto em um modelo do LSD pode conter um ou mais elementos chamados hook, que são ponteiros para outros objetos, assim como \\(cur\\), porém não são temporários, existindo por toda a vida do objeto. Portanto, hooks permitem conectar uma cópia de um objeto a qualquer outra cópia de qualquer outro objeto no modelo. A sua principal vantagem é acelerar operações de busca por objetos.\r\nSufixos e famílias Macro\r\nA maioria das macros do LSD, como V(…), pode ser acrescida de alguns sufixos, como \\(L\\), \\(S\\), \\(LS\\), etc. O sufixo \\(L\\) faz referência a Lag e indica que a operação se refere a valores passados. O sufixo \\(S\\) indica uma cópia Specific de um objeto. \\(LS\\) indica que a macro será aplicada tanto com Lag quanto para uma cópia em específico de um objeto.\r\nFamília V(…)\r\nEssa é a família de macros do LSD mais usada. Composta por V(“X”), VL(“X”, lag), VS(obj, “X”), VLS(obj, “X”, lag). Essas macros retornam o valor da variável ou parâmetro com nome X. As formas VL(“X”, lag) e VLS(obj, “X”, lag) permitem especificar um lag como, por exemplo, VL(“X”, 2) pra um lag de 2 períodos. As formas VS(obj, “X”) e VLS(obj, “X”, lag) especificam em qual objeto específico o parâmetro ou a variável sevem ser procuradas. Em V(“X”) e VL(“X”, lag), onde não é especificado o objeto, a busca começa de \\(p\\) — objeto corrente.\r\nFamília SUM(…)\r\nComposta por SUM(“X”), SUML(“X”, lag), SUMS(obj, “X”), SUMLS(obj, “X”, lag). Essas macros procuram uma instância da variável ou parâmetro X e então começam a somar com todos os valores de instâncias de X encontradas no conjunto de objetos que são cópias do primeiro encontrado.\r\nPor exemplo, seja um modelo composto por um objeto chamado “Mercado”, que contém uma variável chamada “Q_TOT”, e do qual descende um conjunto de objetos chamados “Firmas”, que possuem a variável chamada “Q”. A Equação da soma dos “Q” de todas as firmas seria:\r\nEQUATION( \"Q_TOT\" )\r\n/*  \r\nCalcula a soma de todos os Q's no mercado  \r\n*/\r\n\r\nRESULT( SUM( \"Q\" ) )\r\nÉ importante ressaltar, porém, que se o modelo possuir diversas cópias do objeto “Mercado”, a equação acima só irá computar os “Q” pertencentes às firmas que descendem da cópia do “Mercado” em questão, e não todos os “Q” do modelo. Portanto, se existirem 3 cópias de “Mercado” com 10 cópias de “Firma” em cada um, e “Q” for estabelecido como uma constante igual a 1, “Q_TOT” será 10, para cada objeto “Mercado”, e não 30.\r\nFamília MAX(…)\r\nSemelhante a SUM(“X”), mas ao invés da soma, essa família de macro calcula o valor máximo da variável ou parâmetro chamado “X” entre os descendentes do objeto corrente.\r\nO mesmo ocorre para MIN(…), AVE(…), MED(…) e SD(…), que computam o mínimo, a média, a mediana e o desvio padrão, respectivamente.\r\nFamília WHTAVE(…)\r\nSemelhante a SUM(“X”), mas WHTAVE(“X”,“Y”), ao invés da soma, calcula a média ponderada da variável ou parâmetro chamado “X” entre os descendentes do objeto corrente, usando a variável ou parâmetro chamado “Y” como peso. “X” e “Y” devem estar contidos no mesmo objeto.\r\nFamília SEARCH(…)\r\nComposta por SEARCH(“A”) e SEARCHS(obj, “A”), essas macros exploram um ramo único do model em busca da primeria instância do objeto chamado “A”. Elas procuram dentro dos descendentes do objeto que as está chamado — SEARCH(“A”) — ou dos descentender de um certo objeto “obj” — SEARCHS(obj, “A”). Assim, a busca não é exaustiva sobre o modelo inteiro, a menos que comece do objeto “root” (objeto “pai” de todo e qualquer modelo). É possível partir do “pai” ou “avô” do objeto corrente, utilizando p->up (pai) ou p->up->up (avô).\r\nEssas macros retornam um ponteiro — que pode ser usado (chamado) depois — para a primeira instância do objeto “A” ou NULL caso não seja encontrado nenhum objeto. Por exemplo, deseja-se procurar pelo objeto “Mercado” e sabe-se que ele é avô do objeto que está realizando a busca. O endereço de “Mercado” será salvo no ponteiro temporário cur e depois utilizado para acessar a variável “VendasTotais”:\r\n…  \r\ncur = SEARCH( p->up->up, \"Mercado\" );  \r\nv[1] = VS( cur, \"VendasTotais\" );  \r\n…  \r\nFamília SEARCH_CND(…)\r\nSemelhante à família SEARCH(…), porém as macros SEARCH_CND(“X”, valor) e suas parentes L, S e LS são usadas para encontrar uma instância de um objeto no modelo que contenha a variável, ou parâmetro, chamada “X” com o valor específico apontado. A variante SEARCH_CNDL(“X”, valor, lag) aponta também o lag, com relação ao periodo de tempo corrente, que se deseja procurar o valor para a variável. A variante SEARCH_CNDS(obj, “X”, valor) aponta também o objeto de onde se parte a busca (ao invés do objeto corrente que está chamando a macro).\r\nPor exemplo, deseja-se extrair uma instância aleaória do objeto “Firma”, de um grupo de 100 instâncias que possuem o parâmetro “IdFirma” ajustado de 1 a 100, e alocar o enderço desse objeto no ponteiro temporário cur:\r\n…  \r\nv[0] = uniform_int( 1, 100 );  \r\ncur = SEARCH_CND( \"IdFirma\", v[0] );  \r\n… \r\nFamília SEARCH_INST(…)\r\nComposta por SEARCH_INST(“A”) e SEARCH_INSTS(obj, “A”), essa família de macros procura o número da instância de um objeto cópia do objeto “A”. A variante SEARCH_INSTS(obj, “A”) aponta também o objeto de onde se parte a busca (ao invés do objeto corrente que está chamando a macro). Quando uma instância do objeto é encontrada, a macro retorna um número que representa a posição dessa instância em específico (com relação a essa cadeia de cópias do objeto), começando em 1 e indo até o número total de cópias do objeto em questão.\r\nPor exemplo, deseja-se confirmar se o parâmetro “IdFirma” está ajustado ao número (posição) de cada instância do objeto “Firma”:\r\nCYCLE( cur, \"Firma\" )  \r\n{  \r\n  v[1] = VS( cur, \"IdFirma\" );  \r\n  v[2] = SEARCH_INST( cur );  \r\n  if ( v[1] != v[2] )  \r\n    LOG( \"\\n IdFirma=%g diferente da instância número=%g\", v[1], v[2] );  \r\n} \r\nFamília RDNDRAW(…)\r\nComposta por RDNDRAW(“A”, X“), RDNDRAWL(”A“,”X“, lag), RDNDRAWS(obj,”A“,”X“), RDNDRAWLS(obj,”A“,”X“, lag), essa família de macros procura por um grupo de objetos chamado de”A\" e retorna um ponteiro com o endereço de uma das instâncias do objeto “A”, escolhido de forma aleatória com probabilidade proporcional aos valores da variável “X” (possuida pelo mesmo objeto). A variante S pode começar a busca a partir de outro objeto que não o objeto corrente, e a variante L pode especificar um período anterior que o período corrente.\r\nPor exemplo, deseja-se escolher aleatoriamente uma instância do objeto “Firma” e retornar o valor do seu parâmetro “IdFirma”. O objeto “Firma” é descendente direto do objeto que está rodando a equação. O código atribui o parâmetro “prob”, em cada Firma, ao quadrado do seu market share (“ms”).\r\nEQUATION( \"EscolherFirma\" )  \r\n/***************************  \r\nRetorna o Id da Firma escolhida aleatoriamente com probabilidade igual ao quadrado do market share.    \r\n***************************/ \r\nCYCLE( cur, \"Firma\" )  \r\n{  \r\n  v[0] = V( \"ms\" );  \r\n  WRITES( cur, \"Prob\", v[0] * v[0] );  \r\n}  \r\ncur = RNDDRAW( \"Firma\", \"Prob\" );  \r\nRESULT( VS( cur, \"IdFirma\" ) )  \r\nFamília RDNDRAW_FAIR(…)\r\nComposta por RDNDRAW_FAIR(“A”) e RDNDRAW_FAIRS(obj, “A”), essa família de macros é semelhante à Família RDNDRAW(…), porém usa a mesma probabilidade para todos os objetos. Por exemplo:\r\nEQUATION( \"EscolherFirma\" )  <p style=\"color:green;\">\r\n/***************************  \r\nRetorna o Id da Firma escolhida aleatoriamente com probabilidade igual ao quadrado do market share.    \r\n***************************/ <\/p>  \r\ncur = RNDDRAW_FAIR( \"Firma\");  \r\nRESULT( VS( cur, \"IdFirma\" ) )  \r\nFamília WRITE(…)\r\nComposta por WRITE(“X”, valor), WRITES(obj, “X”, valor), WRITEL(“X”, valor, tempo), WRITELS(obj, “X”, valor, tempo), WRITELL(“X”, valor, tempo, lag), WRITELLS(obj, “X”, valor, tempo, lag), essa família de macros escreve o valor “valor” na variável ou parâmetro “X”. No caso de uma variável, é possível fazer aparecer como se o tempo da ultima computação da variável sendo escrita fosse “tempo”. Ou seja, após a macro ser executada, a variável “X” irá aparecer para o LSD como se sua última computação tivesse sido esecutada no periodo “tempo”, e seu valor fosse “valor”. Se “X” for um prâmetro, o campo “tempo” é ignorado. A variável deve contida pelo objeto corrente ou pelo objeto especificado na variante S. Adicionlamente, a variante LL permite modificar os valores em “lag” da variável (ignorado se for parâmetro), portanto é possível “reescrever o passado”, mudando o valor retornado pelo LSD caso o valor em lag da variável seja requisitado por, por exemplo, uma macro VL(…). Reescrever o passado é algo perigoso e só é recomendado em alguns casos.\r\nO melhor uso dessa família é para mudar os valores de parâmetros durante uma simulação. Um uso frequente em variáveis é para a inicialização de objetos recentemente adicionados.\r\nFamília CYCLE(…)\r\nComposta por CYCLE(cur, “A”), CYCLES(obj, cur, “A”), CYCLE_SAFE(cur, “A”), CYCLE_SAFES(obj, cur, “A”), essa família de macros examina todas as instâncias do objeto “A” — que descende do objeto corrente ou que é apontado na variante S — atribuindo ciclicamente o ponteiro cur para o endenreço de cada instância do objeto. É possivel aninhar dois ou mais CYCLE(…), dado que se utilize diferentes ponteiros (cur, cur1, cur2, etc.) para cada nível.\r\nPor exemplo, deseja-se calcular o lucro total de todas as Firmas, de todos os Mercados (o objeto Mercado contém o objeto Firma). O ponteiro cur cicla através de todos os objetos chamados “Mercado” (supondo que exista mais de 1). Por sua vez, para cada instância de “Mercado”, o ponteiro cur1 cicla através de cada objeto chamado “Firma” que está contido nessa instância em especifico do objeto “Mercado”. Para cada “Firma”\r\n…   \r\nv[0] = 0; // ajustar v[0] para ser inicialmente 0  \r\nCYCLE( cur, \"Mercado\" )  \r\n{ // Para cada Mercado  \r\n  CYCLES( cur, cur1, \"Firma\" )  \r\n  { // para cada Firma contida em cur (instância de Mercado)  \r\n    v[1] = VS( cur1, \"Lucro\" );  // retorne o lucro dessa Firma em específico  \r\n    v[0] = v[0] + v[1];  \r\n  }  \r\n}  \r\n// A partir daqui v[0] contém os lucros acumulados  \r\n…   \r\nNunca use DELETE(…) dentro de um CYCLE(…) para remover uma das instâncias do objeto sendo ciclado. Deletar qualquer objeto apontado por cur impede a macro CYCLE(…) de identificar a próxima instância do objeto. Como alternativo, utiliza-se a macro CYCLE_SAFE(…)\r\nFunções matemáticas e estatísticas\r\nAlém das macros específicas do LSD, é possivel utilizar diversas funções matemáticas e estatísticas.\r\n\r\nAlgumas das funções abaixo só estão disponíveis para compilador C++11 ou maior, o que não é o caso da instalação do LSD Windows 32-bit.\r\nConstantes:\r\n\\(pi\\): o número \\(\\pi\\)\r\nFunções e operadores\r\n\\(abs(a)\\): valor absoluto de \\(a\\)\r\n\\(exp(a)\\): exponencial de \\(a\\)\r\n\\(fact(a)\\): fatorial de \\(a\\)\r\n\\(log(a)\\), \\(log10(a)\\): log natural e com base 10 de \\(a\\)\r\n\\(min(a,b)\\): o mínimo entre \\(a\\) e \\(b\\)\r\n\\(max(a,b)\\): o máximo entre \\(a\\) e \\(b\\)\r\n\\(pow(a,b)\\): a potência \\(b\\) de \\(a\\)\r\n\\(round(a)\\): o inteiro mais próximo de valor real de \\(a\\)\r\n\\(round\\_digits(a,b)\\): o valor real de \\(a\\) arredondado de \\(b\\) dígitos significativos\r\n\\(sin(a)\\), \\(cos(a)\\), \\(tan(a)\\), \\(asin(a)\\), \\(acos(a)\\), \\(atan(a)\\): funções trigonométricas (\\(a\\) em radianos)\r\n\\(sqrt(a)\\), \\(cbrt(a)\\): raís quadrada e cúbica de \\(a\\)\r\n\\(tgamma(a)\\), \\(lgamma(a)\\): função gamma e log-gamma de \\(a\\)\r\nTestes\r\n\\(is\\_finite(a)\\), \\(is\\_inf(a)\\), \\(is\\_nan(a)\\): testes lógicos para checar se \\(a\\) é finito, infinito ou NaN (Not a Number), retornando 0 se for falso\r\nSorteio de número aleatório\r\n\\(alapl(med, \\alpha1, \\alpha2)\\): sorteio aleatório de uma distribuição de Laplace assimétrica com mediana \\(med\\) e parâmetros \\(\\alpha1\\) e \\(\\alpha2\\)\r\n\\(bernoulli(p)\\): sorteio aletório de uma distribuição Bernoulli com probabilidade \\(p\\)\r\n\\(beta(\\alpha, \\beta)\\): sorteio aletório de uma distribuição beta com parâmetros \\(\\alpha\\) e \\(\\beta\\)\r\n\\(binomial(p,t)\\): sorteio aletório de uma distribuição binomial com probabilidade \\(p\\) e \\(t\\) ensaios\r\n\\(cauchy(a,b)\\): sorteio aletório de uma distribuição Cauchy com modo \\(a\\) e escala \\(b\\)\r\n\\(chi\\_squared(n)\\): sorteio aletório de uma distribuição chi quadrada com \\(n\\) graus de liberdade\r\n\\(exponencial(\\lambda)\\): sorteio aletório de uma distribuição exponencial com frequência média \\(\\lambda\\)\r\n\\(fisher(m,n)\\): sorteio aletório de uma distribuição F de Fisher com \\(m\\) e \\(n\\) graus de liberdade\r\n\\(gamma(\\alpha, \\beta)\\): sorteio aletório de uma distribuição gamma com parâmetros \\(\\alpha\\) e \\(\\beta\\)\r\n\\(geometric(p)\\): sorteio aletório de uma distribuição geométrica com probabilidade \\(p\\)\r\n\\(lnorm(mean, dev)\\): sorteio aletório de uma distribuição lognormal com média \\(mean\\) e desvio padrão \\(dev\\)\r\n\\(norm(mean, dev)\\): sorteio aletório de uma distribuição normal com média \\(mean\\) e desvio padrão \\(dev\\)\r\n\\(pareto(\\mu, \\alpha)\\): sorteio aletório de uma distribuição Pareto com escala \\(\\mu\\) e parâmetro shape \\(\\alpha\\)\r\n\\(poisson(mean)\\): sorteio aletório de uma distribuição Poisson com média \\(mean\\)\r\n\\(student(n)\\): sorteio aletório de uma distribuição t de Student com \\(n\\) graus de liberdade\r\n\\(uniform(min, max)\\): sorteio aletório de uma distribuição uniforme no intervalo \\([min,max]\\)\r\n\\(uniform\\_int(min,max)\\): sorteio aletório de números inteiros de uma distribuição uniforme no intervalo \\([min,max]\\)\r\n\\(weibull(a,b)\\): sorteio aletório de uma distribuição Weibull com parâmetros \\(a\\) e \\(b\\)\r\nFunções de distribuição acumulada\r\n\\(alaplcdf(med, \\alpha1, \\alpha2,x)\\): distribuição acumulada asimétrica de Laplace com parâmetros \\(\\alpha1\\) e \\(\\alpha2\\), de \\(-\\infty\\) a \\(x\\)\r\n\\(betacdf(\\alpha,\\beta,x)\\): distribuição acumulada beta com parâmetros \\(\\alpha\\) e \\(\\beta\\) de \\(-\\infty\\) a \\(x\\)\r\n\\(gammacdf(mean,x)\\): distribuição acumulada gamma com média \\(mean\\) de \\(-\\infty\\) a \\(x\\)\r\n\\(lnormcdf(mean,dev,x)\\): distribuição acumulada lognormal com média \\(mean\\) e desvio padrão \\(dev\\) de \\(-\\infty\\) a \\(x\\)\r\n\\(normcdf(mean,dev,x\\): distribuição acumulada normal com média \\(mean\\) e desvio padrão \\(dev\\) de \\(-\\infty\\) a \\(x\\)\r\n\\(paretocdf(\\mu,\\alpha,x\\): distribuição acumulada Pareto com escala \\(\\mu\\) e parâmetro shape \\(\\alpha\\) de \\(-\\infty\\) a \\(x\\)\r\n\\(poisson(mean,x)\\): distribuição acumulada Poisson com média \\(mean\\) de \\(-\\infty\\) a \\(x\\)\r\n\\(unifcdf(min,max,x)\\): distribuição acumulada uniforme no intervalo \\([min,max]\\) de \\(-\\infty\\) a \\(x\\)\r\nCódigo C++ básico\r\nDentro da Equação de uma variável — ou seja, entre EQUATION(…) e RESULT(…) — é possível usar qualquer elemento ou construção legal do C++. Como já visto, toda linha de código dentro da Equação termina com um ponto e vírgula “;” — a menos que seja um comando operando sobre um bloco de código, como “if(…)” —, o que faz parte da sintaxe do C++. Outro exemplo de sintaxe do C++ já visto é a dos comentários:\r\n/*  \r\nEsse é um comentário  \r\ncom mais de uma linha  \r\n*/  \r\n// Esse é um comentário com apenas uma linha  \r\nAtribuições, operações aritméticas e incrementos\r\nSendo \\(a\\) uma variável (de C++), é possível lhe atribuir um valor com o comando “=”:\r\na = 4.3;\r\nToda atribuição em C++ precisa terminar com um ponto e vírgula.\r\nÉ possível também atribuir valores de outras variáveis, assim como usar operações matemáticas:\r\na = b + 3 - d / (e + g) * (h + i);\r\nUm pouco menos óbvio, é possível usar a mesma variável nos dois lados da atribuição:\r\na = a + 32;\r\nO comando acima atribui a \\(a\\) o seu valor prévio mais um acréscimo de 32. Portanto, caso \\(a\\) tivesse o valor de 5, após o comando acima \\(a\\) teria o valor de 37.\r\nEsse tipo de operação é tão comum que existe uma forma reduzida de escrevê-lo: \\(a\\ +\\!= 32;\\). O mesmo pode ser feito com outras operações aritméticas:\r\n\\(a = a / 32;\\)     é equivalente a     \\(a\\  /\\!= 32;\\)\r\n\\(a = a * 32;\\)     é equivalente a     \\(a\\ *\\!= 32;\\)\r\n\\(a = a - 32;\\)     é equivalente a     \\(a\\ -\\!= 32;\\)\r\nUm comando peculiar de C++ permite tanto incrementar por 1 uma variável como atribuí-la: “\\(++\\)”. Assim:\r\n\\(a = a + 1;\\)     é equivalente a     \\(a\\  +\\!= 1;\\)     que é equivalente a     \\(a++\\)\r\nO comando \\(b = a++;\\), por exemplo, primeiro atribui o valor de \\(a\\) a \\(b\\) e depois incrementa \\(a\\).\r\nÉ possível também primeiro incrementar a variável e depois atribuir: \\(++a\\).\r\nCondições: if …, then …, else …\r\nA função if() é uma forma de executar blocos de código apenas sobre determinadas condições:\r\nif ( condição )  \r\n{   \r\n  // colocar aqui alguma linha de comando a ser executada caso a \"condição\" seja verdadeira  \r\n}  \r\nelse  \r\n{   \r\n  // colocar aqui alguma linha de comando a ser executada caso a \"condição\" seja falsa  \r\n} \r\nOs colchetes “{” e “}” não são necessários caso haja apenas uma linha de comando (terminada com “;”).\r\nA condição do if() normalmente é baseada nos seguintes operadores de comparação (\\(a\\) e \\(b\\) são dois valores numéricos ou variáveis contendo valores numéricos):\r\nIgual \\((a == b)\\): a condição é verdadeira se \\(a\\) e \\(b\\) forem iguais\r\nDiferente \\((a\\ !\\!= b)\\): a condição é verdadeira se \\(a\\) e \\(b\\) forem diferentes\r\nMaior que \\((a > b)\\): a condição é verdadeira se \\(a\\) for maior que \\(b\\)\r\nMaior ou igual \\((a >= b)\\): a condição é verdadeira se \\(a\\) for maior ou igual a \\(b\\)\r\nMenor que \\((a < b)\\): a condição é verdadeira se \\(a\\) for menor que \\(b\\)\r\nMenor ou igual \\((a <= b)\\): a condição é verdadeira se \\(a\\) for menor ou igual a \\(b\\)\r\nA condição pode ainda ser composta por operadores lógicos conectando as comparações:\r\nNegação (!(condição)): é verdadeiro se a condição for falsa\r\nLógico “e” (&&): dadas duas condições, a condição compostas é verdadeira se as duas condições, necessariamente, forem verdadeiras\r\nLógico “ou” (||): dadas duas condições, a condição compostas é verdadeira se uma ou as duas condições forem verdadeiras\r\nCiclos for(...)\r\nEsse comando permite a repetição de um bloco de código até que uma condição específica seja satisfeita. A sua sintaxe é a seguinte:\r\nfor ( INI ; CONDIÇÂO ; FIMCICLO )  \r\n{  \r\n  // Bloco de código do ciclo  \r\n  // Pode haver qualquer comando aqui \r\n}  \r\nPor exemplo:\r\nfor ( i = -2; i < 3; i++ )  \r\n{\r\n  // na execução dessas linhas, i assume os valores -2, -1, 0, 1, 2 \r\n  v[i] = i;  \r\n}   \r\n// aqui, i é igual a 3, porque foi a condição para sair do ciclo \r\n\r\n\r\n\r\n",
    "preview": "posts/2021-01-13-lsdmacro/lsd.png",
    "last_modified": "2021-02-09T10:47:02-03:00",
    "input_file": {},
    "preview_width": 253,
    "preview_height": 107
  },
  {
    "path": "posts/2021-01-12-eqestoc/",
    "title": "Equações em Diferença Estocásticas",
    "description": "Este Post discute Equações em Diferença Estocásticas.",
    "author": [
      {
        "name": "Rafael Peixoto",
        "url": {}
      }
    ],
    "date": "2021-01-13",
    "categories": [
      "Introdução",
      "Matemática"
    ],
    "contents": "\r\n\r\nContents\r\nIntrodução\r\nEquação homogênea\r\nEquação não-homogênea\r\nConclusão\r\n\r\nIntrodução\r\nEquações em diferença estocásticas, como o nome deixa claro, são equações em difereça que possuem algum componente estocástico. É comum encontrá-las em modelos de séries temporais, como, por exemplo, ruído branco \\(x_t = \\epsilon_t\\) ou passeio aleatório \\(x_t = x_{t-1} + \\epsilon_t\\).\r\n\r\n\r\n\r\n\r\n\r\n\r\nO ruído branco é um processo com média zero e variância constante. No caso do gráfico, está sendo utilizado uma ruído branco com distribuição normal e variância igual a um. O passeio aleatório é uma equação em diferença de primeira ordem não-homogênea, \\(x_t - \\theta x_{t-1} = f(t)\\), onde o termo \\(f(t)\\) é um processo de ruído branco e o termo \\(\\theta\\) é igual a um. Caso \\(\\theta > 1\\) ou \\(\\theta < -1\\), a equação explode. Caso \\(-1 < \\theta < 1\\), a equação oscila em torno de um valor. Caso o termo \\(f(t)\\) seja composto por um ruído branco mais uma constante, ou seja \\(f(t) = \\epsilon_t + c\\), a equação apresenta uma um drift.\r\n\r\n\r\n\r\nSeja uma equação em diferença de primeira ordem não-homogênea\r\n\\[\r\nx_t - \\theta x_{t-1} = f(t)\r\n\\] A solução geral irá consistir na soma de dois componentes:\r\na solução particular \\(x_p\\), que é qualquer solução da equação não-homogênea\r\na função complementar \\(x_c\\), que é a solução geral da equação reduzida (homogênea) \\(x_t - \\theta x_{t-1} = 0\\)\r\nEquação homogênea\r\nA equação em diferença homogênea de primeira ordem \\(x_t - \\theta x_{t-1} = 0\\) possui a seguinte solução:\r\n\\[\r\n\\begin{aligned}\r\nx_t = C(\\theta)^t\r\n\\end{aligned}\r\n\\]\r\nEm que:\r\n\\(\\theta > 1\\): solução explosiva, não oscilatória.\r\n\\(0 < \\theta < 1\\): solução convergente, não oscilatória.\r\n\\(-1 < \\theta < 0\\): solução convergente, oscilatória.\r\n\\(\\theta < -1\\): solução explosiva, oscilatória.\r\nCaso \\(\\theta\\) seja uma variável estocástica, é possível que ela apresente diferentes valores ao longo do tempo, fazendo com que o comportamento da equação varie ao longo do tempo, conforme o valor de \\(\\theta\\).\r\n\r\n\r\n\r\n\r\n\r\n\r\nEquação não-homogênea\r\nPara resolver uma equação não-homogênea, \\(x_t - \\theta x_{t-1} = f(t)\\), é preciso achar a solução particular e depois somá-la com a função complementar da equação homogênea. Para tanto, é possível escolher qualquer solução da equação.\r\nComo visto, o passeio aleatório, \\(x_t = x_{t-1} + \\epsilon_t\\), é uma equação em diferença de primeira ordem não-homogênea em que \\(\\theta = 1\\). Caso haja drift, \\(f(t) = \\epsilon_t + c\\).\r\nAssim como foi feito para a equação homogêna, vejamos o comportamento da equação não-homogênea para diferentes \\(\\theta\\):\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nAssim como nas equações homogêneas, nas não-homogêneas:\r\n\\(\\theta < 0\\) faz a equação oscilar\r\n\\(|\\theta| > 1\\) faz a equação explodir.\r\nO drift afeta mais os valores da série (os pontos de convergência) gerada pela equação quando \\(\\theta > 0\\) pois esses deslocamentos se reinforçam, ao contrário do que ocorre quando \\(\\theta < 0\\). Mas, de toda forma, o drift não muda o comportamento da equação (oscilatória ou não, convergente ou divergente). Além disso, esse comportamento não depende do valor inicial \\(x_0\\), a menos que esse coincida com o ponto fixo da equação.\r\nConclusão\r\nA equação em diferença \\(x_t - \\theta x_{t-1} = f(t)\\) tem seu comportamento determinado principalmente por \\(\\theta\\), independentemente de \\(f(t)\\) apresentar componentes estocásticos ou não.\r\nEquação Estocástica App\r\nUtilize o aplicativo abaixo para experimentar diferentes configurações da equação de primeira ordem.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nREGINATTO, V. O. Equações a diferenças. Disponível em: <https://www.modelodomundo.com/2019/03/equa%C3%A7%C3%B5es-a-diferen%C3%A7as/>. \r\n\r\n\r\n\r\n\r\n",
    "preview": "posts/2021-01-12-eqestoc/eqestoc_files/figure-html5/unnamed-chunk-1-1.png",
    "last_modified": "2021-01-29T23:22:30-03:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "posts/2021-01-12-segordem/",
    "title": "Equações de Segunda Ordem",
    "description": "Este Post discute Equações em Diferença de Segunda Ordem.",
    "author": [
      {
        "name": "Rafael Peixoto",
        "url": {}
      }
    ],
    "date": "2021-01-12",
    "categories": [
      "Introdução",
      "Matemática"
    ],
    "contents": "\r\n\r\nContents\r\nIntrodução\r\nEquação homogênea\r\nEquação não-homogênea\r\nConclusão\r\n\r\nIntrodução\r\nUma equação em diferença de segunda ordem é uma equação que envolve a expressão \\(\\Delta ^2 x_t\\), chamada de segunda diferença de \\(x_t\\), mas que não contém diferenças de ordem maior que \\(2\\). O símbolo \\(\\Delta ^2\\) é uma instrução de que está se tomando a segunda diferença:\r\n\\[\r\n\\begin{aligned}\r\n& \\Delta ^2 x_t \r\n\\begin{aligned}\r\n& = \\Delta (\\Delta x_t) \\\\\r\n& = \\Delta (x_t - x_{t-1}) \\\\\r\n& = (x_t - x_{t-1}) - (x_{t-1} - x_{t-2}) \\\\\r\n& = x_t -2x_{t-1} + x_{t-2}\r\n\\end{aligned}\r\n\\end{aligned}\r\n\\]\r\nAssim, a segunda diferença de \\(x_t\\) é transformável em uma soma de termos envolvendo uma diferença de dois períodos de tempo.\r\nDe forma geral, uma equação de segunda ordem pode ser expressa por:\r\n\\[\r\n\\begin{aligned}\r\n& ax_t + bx_{t-1} + cx_{t-2} = f(t)\r\n\\end{aligned}\r\n\\]\r\nEquação homogênea\r\nAssim como para equações de primeira ordem, é possível separar equações de segunda ordem em função complementar e solução particular. Vamos começar pela função complementar, que é a solução geral da equação homogênea.\r\nSeja a equação homogênea:\r\n\\[\r\n\\begin{aligned}\r\n& ax_t + bx_{t-1} + cx_{t-2} = 0\r\n\\end{aligned}\r\n\\] ou, de forma equivalente:\r\n\\[\r\n\\begin{aligned}\r\n& ax_{t+2} + bx_{t+1} + cx_t = 0\r\n\\end{aligned}\r\n\\]\r\nPara encontrar a função complementar de uma equação de segunda ordem, utiliza-se o seguinte articífio:\r\n\\[\r\n\\begin{aligned}\r\n& x_t = \\lambda ^t \\\\\r\n& x_{t+1} = \\lambda ^{t+1} = \\lambda ^t \\lambda \\\\\r\n& x_{t+2} = \\lambda ^{t+2} = \\lambda ^t \\lambda ^2 \\\\[10pt]\r\n& a \\lambda ^2 \\lambda ^t + b \\lambda \\lambda ^t + c \\lambda ^t = 0 \\\\\r\n& \\lambda ^t (a \\lambda ^2 + b \\lambda + c ) = 0 \\\\\r\n& a \\lambda ^2 + b \\lambda + c  = 0\r\n\\end{aligned}\r\n\\]\r\n\\(a \\lambda ^2 + b \\lambda + c = 0\\) também é chamada de equação característica. Como é uma equação de segundo grau, seu \\(\\Delta\\) pode apresentar \\(3\\) resultados possíveis: pode ser negativo, pode ser zero, pode ser positivo. Caso seja positivo, basta utilizar as duas soluções encontradas. Caso seja zero (o que apresenta apenas uma solução \\(x_t\\)), a segunda solução toma a forma de \\(tx_t\\). Caso seja negativo, é necessário calcular a parte imaginária.\r\nExemplo 1: Seja a equação \\(2x_{t+2} - 5x_{t+1} + 2x_t = 0\\). A equação característica é:\r\n\\[\r\n\\begin{aligned}\r\n& 2 \\lambda ^2 - 5 \\lambda + 2 = 0 \\\\[10pt]\r\n& \\Delta = (-5)^2 - 4(2)(2) = 25 - 16 = 9 \\\\\r\n& \\lambda = \\frac{5 \\pm 3}{4} \\\\\r\n& \\begin{cases}\r\n\\lambda_1 = 2 \\\\\r\n\\lambda_2 = \\frac{1}{2}\r\n\\end{cases}\r\n\\end{aligned}\r\n\\]\r\nPortanto, a solução da equação homogênea é:\r\n\\[\r\n\\begin{aligned}\r\n& x_t = \\lambda ^t \\\\[10pt]\r\n& \\begin{cases}\r\nx_t = (2)^t \\\\\r\nx_t = (\\frac{1}{2})^t\r\n\\end{cases} \\\\[10pt]\r\n& x_t = A(2)^t + B(\\frac{1}{2})^t\r\n\\end{aligned}\r\n\\]\r\nDado que as condições iniciais sejam, por exemplo:\r\n\\[\r\n\\begin{aligned}\r\n& \\begin{cases}\r\nx_0 = 2 \\\\\r\nx_1 = \\frac{11}{2}\r\n\\end{cases} \\\\[10pt]\r\n& x_0 = A(2)^0 + B(\\frac{1}{2})^0 = A + B = 2 \\\\\r\n& x_1 = A(2)^1 + B(\\frac{1}{2})^1 = 2A + \\frac{1}{2}B = \\frac{11}{2} \\\\[10pt]\r\n& \\begin{cases}\r\nA + B = 2 \\\\\r\n4A + B = 11 \r\n\\end{cases} \\\\[10pt]\r\n& A = 3; \\quad B= -1 \\\\[10pt]\r\n\\end{aligned}\r\n\\]\r\nA solução final fica:\r\n\\[\r\n\\begin{aligned}\r\n& x_t = 3(2)^t -(\\frac{1}{2})^t\r\n\\end{aligned}\r\n\\]\r\nComo a solução possui um \\(\\lambda > 1\\), a equação apresentará um comportamento explosivo, de forma semelhante a equações de primeira ordem com \\(\\theta >1\\). Vejamos um grafico da sua dinâmica:\r\n\r\n\r\n\r\nEquação não-homogênea\r\nAssim como para equações de primeira ordem, a equação não-homogênea de segunda ordem tem como solução a soma da função complementar e da solução particular, e pode ser expressa genericamente por:\r\n\\[\r\n\\begin{aligned}\r\n& ax_t + bx_{t-1} + cx_{t-2} = f(t)\r\n\\end{aligned}\r\n\\]\r\nExemplo 2: Seja a equação \\(x_{t+2} - 2x_{t+1} +x_t = 2\\). A Equação homogênea seria \\(x_{t+2} - 2x_{t+1} +x_t = 0\\), com equação característica \\(\\lambda^2 - 2\\lambda + 1 = 0\\). Vamos achar a função complementar:\r\n\\[\r\n\\begin{aligned}\r\n& \\Delta = (-2)^2 -4(1)(1) = 0 \\\\\r\n& \\lambda = \\frac{2 \\pm \\sqrt{0}}{(2)(1)} = 1 \\\\[10pt]\r\n& x_t = A(1)^t + Bt(1)^t \\\\\r\n& x_t = A + Bt\r\n\\end{aligned}\r\n\\]\r\nAchada a solução da equação homogênea, o próximo passo é encontrar a solução particular da não-homogênea. Como os três primeiros casos de solução de não-homogênea (\\(x_t = A\\), \\(x_t = At\\) e \\(x_t = A + Bt\\)) não são adequados (eles já são solução da equação homogênea), parte-se para o caso \\(x_t = At^2\\):\r\n\\[\r\n\\begin{aligned}\r\n& x_t = At^2 \\\\\r\n& x_{t+1} = A(t+1)^2 = At^2 + 2At + A \\\\\r\n& x_{t+2} = A(t+2)^2 = At^2 + 4At + 4A \\\\[10pt]\r\n& x_{t+2} - 2x_{t+1} +x_t = 2 \\\\\r\n& At^2 + 4At + 4A - 2At^2 - 4At - 2A + At^2 = 2 \\\\\r\n& 2A = 2 \\\\\r\n& A = 1 \\\\[10pt]\r\n& x_t = At^2 \\\\\r\n& x_t = t^2\r\n\\end{aligned}\r\n\\]\r\nCom isso, a solução geral da equação, que é a soma da função complementar e da solução particular, fica:\r\n\\[\r\n\\begin{aligned}\r\n& x_t = A + Bt + t^2\r\n\\end{aligned}\r\n\\]\r\nDado que as condições iniciais sejam, por exemplo:\r\n\\[\r\n\\begin{aligned}\r\n& \\begin{cases}\r\nx_0 = 1 \\\\\r\nx_1 = 3\r\n\\end{cases} \\\\[10pt]\r\n& x_0 = A + B(0) + 0^2 = A = 1 \\\\\r\n& x_1 = A + B(1) + 1^2 = 2 + B = 3 \\\\[10pt]\r\n& A = 1; \\quad B = 1 \\\\\r\n\\end{aligned}\r\n\\]\r\nA solução final fica:\r\n\\[\r\n\\begin{aligned}\r\n& x_t = 1 + t + t^2\r\n\\end{aligned}\r\n\\]\r\nConclusão\r\nAssim como para equações em diferença de primeira ordem, as equações de segunda ordem também possuem uma solução que é a soma da função complementar com a solução particular:\r\n\\[\r\n\\begin{aligned}\r\n& x_t = x_c + x_p \\\\\r\n\\end{aligned}\r\n\\]\r\nPorém, a função complementar irá chegar na equação característica, que segue a forma:\r\n\\[\r\n\\begin{aligned}\r\n& a \\lambda ^2 + b \\lambda + c  = 0\r\n\\end{aligned}\r\n\\]\r\n\r\n\r\n\r\nNEUSSER, K. Difference equations for economists. Unpublished manuscript, October, v. 3, 2016. \r\n\r\n\r\nSARTORIS, A. Equações a diferenças de 2a ordem. Disponível em: <https://www.youtube.com/watch?v=Q4Bj6XJtcz4>. \r\n\r\n\r\nWAINWRIGHT, K.; CHIANG, A. C. Fundamental methods of mathematical economics. Traducao. [s.l.] Boston, Mass.: McGraw-Hill/Irwin, 2005. \r\n\r\n\r\n\r\n\r\n",
    "preview": "posts/2021-01-12-segordem/segordem_files/figure-html5/unnamed-chunk-1-1.png",
    "last_modified": "2021-01-12T19:21:53-03:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "posts/2021-01-06-primordem/",
    "title": "Equações de Primeira Ordem",
    "description": "Este Post discute Equações em Diferença de Primeira Ordem.",
    "author": [
      {
        "name": "Rafael Peixoto",
        "url": {}
      }
    ],
    "date": "2021-01-11",
    "categories": [
      "Introdução",
      "Matemática"
    ],
    "contents": "\r\n\r\nContents\r\nIntrodução\r\nSoluçãoMétodo Iterativo\r\nMétodo Geral\r\n\r\nAplicaçõesModelo da Teia de Aranha\r\nModelo de Harrod\r\n\r\nConclusão\r\n\r\nIntrodução\r\nEm contextos em que o tempo é tomado como uma variável discreta — ou seja, a variável \\(t\\) só pode assumir valores inteiros —, o padrão de mudança de uma variável \\(x\\) deve ser descrito pelas chamadas equações em diferença, ao invés de por equações diferenciais ou derivativas.\r\nComo \\(t\\) só pode assumit valores inteiros, quando se compara valores de \\(x\\) em dois períodos consecutivos, tem-se que \\(\\Delta t = 1\\), portanto, o padrão de mudança \\(\\frac{\\Delta x}{\\Delta t}\\) pode ser simplificado para \\(\\Delta x\\). essa é a primeira diferença de \\(x\\). Adicionando-se o subscrito referente ao periodo em que ocorre a mudança \\(\\Delta x\\), tem-se:\r\n\\[\r\n\\Delta x_t \\equiv x_t - x_{t-1}\r\n\\]\r\nAssim, padrões de mudança como \\(\\Delta x_t = 2\\) podem ser expresas como\r\n\\[\r\n\\begin{aligned}\r\n& x_t - x_{t-1} = 2 \\\\\r\n& x_t = x_{t-1} + 2\r\n\\end{aligned}\r\n\\]\r\nEquações em Diferença podem ser:\r\nlinear ou não-linear\r\nhomogênea ou não-homogênea\r\nde primeira ordem ou ordem maior\r\nEsse texto visa analisar apenas equações de primeira ordem, ou seja, equações que envolvem apenas uma diferença de um período. Portanto, salvo indicação, toda vez que em que aparecer o termo equação, este estará se referindo a equações em diferenças de primeira ordem.\r\nUm exemplo de equação de primeira ordem linear e não-homogênea é a seguinte equação afim:\r\n\\[\r\nx_t = \\theta x_{t-1} + z_t, \\qquad \\theta \\ne 0\r\n\\]\r\nA equação homogênea correspondente seria\r\n\\[\r\nx_t = \\theta x_{t-1}\r\n\\]\r\nSolução\r\nA trajetória no tempo, de uma equação em diferença, deve ser uma função de \\(t\\) — uma fórmula definindo os valores de \\(x\\) em cada período de tempo — consistente com a dada equação e com as condições iniciais.\r\nMétodo Iterativo\r\nAntes de apresentar um método geral de solução de equações em diferença, é interessante discutir o método iterativo, que, embora rústico, ajuda a entender a natureza das soluções desse tipo de equação.\r\nEquações de primeira ordem descrevem o padrão de mudança de \\(x\\) entre dois períodos consecutivos. Uma vez que esse padrão é especificado — e.g. \\(\\Delta x_t = 2\\) —, e uma vez que é dado um valor inicial \\(x_0\\), não é problema encontrar \\(x_1\\) com a equação. De forma semelhante, uma vez encontrado \\(x_1\\), é possível obter \\(x_2\\), e assim por diante, iterando o madrão de mudança especificado pela equação em diferença.\r\nExemplo 1: Seja a equação em diferença \\(\\Delta x_t = 2\\), assumindo um valor inicial \\(x_0 = 15\\). É possível inferir a trajetória da variável \\(x\\) iterando a equação, a partir do valor inivial dado.\r\n\\[\r\n\\begin{aligned}\r\n& \\Delta x_t = 2 \\\\\r\n& x_t - x_{t-1} = 2 \\\\\r\n& x_t = x_{t-1} + 2 \\\\\r\n& x_1 = x_0 + 2 \\\\\r\n& x_2 = x_1 + 2 = (x_0 + 2) + 2 = x_0 + 2(2) \\\\\r\n& x_3 = x_2 + 2 = [x_0 + 2(2)] + 2 = x_0 + 3(2) \\\\\r\n& \\dots\r\n\\end{aligned}\r\n\\]\r\nEm geral, para qualquer período \\(t\\):\r\n\\[\r\nx_t = x_0 + t(2)\r\n\\]\r\nComo foi estabelecido que \\(x_0 = 15\\):\r\n\\[\r\nx_t = 15 + 2t\r\n\\]\r\nExemplo 2: Seja a equação em diferença \\(x_t = 0.9x_{t-1}\\), com um valor inicial não especificado. Por iteração tem-se:\r\n\\[\r\n\\begin{aligned}\r\n& x_1 = 0.9x_0 \\\\\r\n& x_2 = 0.9x_1 = 0.9(0.9x_0) = (0.9)^2x_0 \\\\\r\n& x_3 = 0.9x_2 = 0.9(0.9)^2x_0 = (0.9)^3x_0 \\\\\r\n& \\dots\r\n\\end{aligned}\r\n\\]\r\nEm geral, para qualquer período \\(t\\):\r\n\\[\r\nx_t = (0.9)^tx_0\r\n\\]\r\nExemplo 3: Seja a equação em diferença \\(x_t = 2x_{t-1}\\). Por iteração, tem-se:\r\n\\[\r\n\\begin{aligned}\r\n& x_1 = 2x_0 \\\\\r\n& x_2 = 2x_1 = 2(2x_0) = (2)^2x_0 \\\\\r\n& x_3 = 2x_2 = 2(2)^2x_0 = (2)^3x_0 \\\\\r\n& \\dots\r\n\\end{aligned}\r\n\\]\r\nEm geral, para qualquer período \\(t\\):\r\n\\[\r\nx_t = (2)^tx_0\r\n\\]\r\nExemplo 4: Seja a equação em diferença \\(x_t = -4x_{t-1}\\). Por iteração, tem-se:\r\n\\[\r\n\\begin{aligned}\r\n& x_1 = -4x_0 \\\\\r\n& x_2 = -4x_1 = -4(-4x_0) = (-4)^2x_0 \\\\\r\n& x_3 = -4x_2 = -4(-4)^2x_0 = (-4)^3x_0 \\\\\r\n& \\dots\r\n\\end{aligned}\r\n\\]\r\nEm geral, para qualquer período \\(t\\):\r\n\\[\r\nx_t = (-4)^tx_0\r\n\\]\r\nExemplo 5: Seja a equação em diferença \\(x_t = -\\frac{1}{2}x_{t-1}\\). Por iteração, tem-se:\r\n\\[\r\n\\begin{aligned}\r\n& x_1 = -\\frac{1}{2}x_0 \\\\\r\n& x_2 = -\\frac{1}{2}x_1 = -\\frac{1}{2}(-\\frac{1}{2}x_0) = (-\\frac{1}{2})^2x_0 \\\\\r\n& x_3 = -\\frac{1}{2}x_2 = -\\frac{1}{2}(-\\frac{1}{2})^2x_0 = (-\\frac{1}{2})^3x_0 \\\\\r\n& \\dots\r\n\\end{aligned}\r\n\\]\r\nEm geral, para qualquer período \\(t\\):\r\n\\[\r\nx_t = (-\\frac{1}{2})^tx_0\r\n\\]\r\nMétodo Geral\r\nSeja uma equação em diferença de primeira ordem não-homogênea\r\n\\[\r\nx_t - \\theta x_{t-1} = f(t)\r\n\\] A solução geral irá consistir na soma de dois componentes:\r\na solução particular \\(x_p\\), que é qualquer solução da equação não-homogênea\r\na função complementar \\(x_c\\), que é a solução geral da equação reduzida (homogênea) \\(x_t - \\theta x_{t-1} = 0\\)\r\nO componente \\(x_p\\) representa nível de equilíbrio intertemporal de \\(x\\), e o componente \\(x_c\\) representa os desvios da trajetória desse equilíbrio. A soma dos dois constitui a solução geral devido à presença de uma constante arbitrária. Para definir a solução, é necessário um condição inicial.\r\nFunção Complementar\r\nOs exemplos 2 a 5 mostraram a aplicação do método iterativo em equações homogêneas. Essas equações possuem a forma geral\r\n\\[\r\nx_t - \\theta x_{t-1} = 0\r\n\\]\r\nou\r\n\\[\r\nx_t = \\theta x_{t-1}\r\n\\]\r\nComo visto, em todos esses exemplos, a solução encontrada tomou a forma\r\n\\[\r\nx_t = (\\theta)^tx_0\r\n\\]\r\nComo \\(x_0\\) é uma constante, essa solução também aparece como\r\n\\[\r\n\\begin{aligned}\r\n\\boxed{x_t = C(\\theta)^t}\r\n\\end{aligned}\r\n\\]\r\n\r\np.s. \\(C\\) só é igual a \\(x_0\\) em equações homogêneas. O mesmo não vale para equações não-homogêneas\r\nAlém disso, os exemplos demonstraram quatro casos possíveis para esse tipo de equações:\r\n\\(\\theta > 1\\): solução explosiva, não oscilatória.\r\n\\(0 < \\theta < 1\\): solução convergente, não oscilatória.\r\n\\(-1 < \\theta < 0\\): solução convergente, oscilatória.\r\n\\(\\theta < -1\\): solução explosiva, oscilatória.\r\nSolução Particular\r\nComo mencionado acima, para \\(x_p\\) é possível escolher qualquer solução da equação. Assim, uma estratégia muito utilizada é partir da forma mais simples possível e ir adicionando elementos conforme a solução nao se mostre adequada. De forma mais concreta, usualmente segue-se a seguinte ordem:\r\n\\(x_t = A\\)\r\n\\(x_t = At\\)\r\n\\(x_t = At + B\\)\r\nCaso 1: Seja a equação não-homogênea \\(x_t - 0.5x_{t-1} = 2\\). A equação reduzida seria \\(x_t = 0.5x_{t-1}\\), e sua função complementar \\(x_t = C(0.5)^t\\). A solução particular da não-homogênea seria:\r\n\\[\r\n\\begin{aligned}\r\n& x_t = A \\\\\r\n& x_{t-1} = A \\\\[10pt]\r\n& x_t - 0.5x_{t-1} = 2 \\\\\r\n& A - 0.5A = 2 \\\\\r\n& A = 4\r\n\\end{aligned}\r\n\\]\r\nA solução geral seria:\r\n\\[\r\n\\begin{aligned}\r\n& x_t = x_c + x_p \\\\\r\n& x_t = C(\\theta)^t + A \\\\\r\n& x_t = C(0.5)^t + 4\r\n\\end{aligned}\r\n\\]\r\nCaso, por exemplo, a condição inicial seja \\(x_0 = 3\\):\r\n\\[\r\n\\begin{aligned}\r\n& x_0 = C(0.5)^0 + 4 = 3 \\\\\r\n& C = 3 - 4 \\\\\r\n& C = -1 \\\\[10pt]\r\n& x_t = -1(0.5)^t + 4 \\\\\r\n& x_t = 4 - (0.5)^t\r\n\\end{aligned}\r\n\\]\r\nCaso 2: Seja a equação não-homogênea \\(x_t - x_{t-1} = 3\\). A equação reduzida seria \\(x_t = x_{t-1}\\), e sua função complementar \\(x_t = C(1)^t = C\\). A solução particular da não-homogênea seria:\r\n\\[\r\n\\begin{aligned}\r\n& x_t = A \\\\\r\n& x_{t-1} = A \\\\[10pt]\r\n& x_t - x_{t-1} = 3 \\\\\r\n& A - A = 3 \\\\\r\n& 0A = 3\r\n\\end{aligned}\r\n\\]\r\nEssa solução particular não é adequada, portanto parte-se para o segundo caso.\r\n\\[\r\n\\begin{aligned}\r\n& x_t = At \\\\\r\n& x_{t-1} = A(t-1) \\\\[10pt]\r\n& x_t - x_{t-1} = 3 \\\\\r\n& At - (At - A) = 3 \\\\\r\n& At - At + A = 3 \\\\\r\n& A = 3\r\n\\end{aligned}\r\n\\]\r\nA solução geral seria\r\n\\[\r\n\\begin{aligned}\r\n& x_t = x_c + x_p \\\\\r\n& x_t = C(\\theta)^t + At \\\\\r\n& x_t = C + 3t\r\n\\end{aligned}\r\n\\]\r\nCaso, por exemplo, a condição inicial seja \\(x_0 = 5\\):\r\n\\[\r\n\\begin{aligned}\r\n& x_0 = C + 3(0) = 5 \\\\\r\n& C = 5 \\\\[10pt]\r\n& x_t = C + 3t \\\\\r\n& x_t = 5 + 3t\r\n\\end{aligned}\r\n\\]\r\nCaso 3: Seja a equação não-homogênea \\(x_t + 2x_{t-1} = t\\). A equação reduzida seria \\(x_t = -2x_{t-1}\\), e sua função complementar \\(x_t = C(-2)^t\\). A solução particular da não-homogênea seria:\r\n\\[\r\n\\begin{aligned}\r\n& x_t = At \\\\\r\n& x_{t-1} = A(t-1) \\\\[10pt]\r\n& x_t + 2x_{t-1} = t \\\\\r\n& At + 2(At - A) = t \\\\\r\n& At + 2At - 2A = t \\\\\r\n& 3At - 2A = t + 0 \\\\\r\n& \\begin{cases}\r\n  3A = 1 \\\\\r\n  -2A = 0\r\n  \\end{cases}\r\n\\end{aligned}\r\n\\]\r\nEssa solução particular não é adequada, portanto parte-se para o terceiro caso.\r\n\\[\r\n\\begin{aligned}\r\n& x_t = At + B\\\\\r\n& x_{t-1} = A(t-1) + B\\\\[10pt]\r\n& x_t + 2x_{t-1} = t \\\\\r\n& At + B + 2(At - A + B) = t \\\\\r\n& At + B +2At - 2A + 2B = t \\\\\r\n& 3At - 2A + 3B = t + 0 \\\\\r\n& \\begin{cases}\r\n  3A = 1 \\\\\r\n  -2A + 3B = 0\r\n  \\end{cases} \\\\\r\n& A = \\frac{1}{3}; \\qquad B = \\frac{2}{9}\r\n\\end{aligned}\r\n\\]\r\nA solução geral seria\r\n\\[\r\n\\begin{aligned}\r\n& x_t = x_c + x_p \\\\\r\n& x_t = C(\\theta)^t + At + B \\\\\r\n& x_t = C(-2)^t + \\frac{1}{3}t + \\frac{2}{9}\r\n\\end{aligned}\r\n\\]\r\nCaso, por exemplo, a condição inicial seja \\(x_0 = \\frac{20}{9}\\):\r\n\\[\r\n\\begin{aligned}\r\n& x_0 = C(-2)^0 + \\frac{1}{3}(0) + \\frac{2}{9} = \\frac{20}{9} \\\\\r\n& C = \\frac{20}{9} - \\frac{2}{9} \\\\\r\n& C = 2 \\\\[10pt]\r\n& x_t = C(-2)^t + \\frac{1}{3}t + \\frac{2}{9} \\\\\r\n& x_t = 2(-2)^t + \\frac{1}{3}t + \\frac{2}{9}\r\n\\end{aligned}\r\n\\]\r\nAplicações\r\nVejamos dois exemplos simples de modelos econômicos que utilizam equações em diferença.\r\nModelo da Teia de Aranha\r\nEsse é um modelo de demanda e oferta que utiliza o tempo discreto, portanto é definido com equações em diferença. Seja as equações de oferta e demanda:\r\n\\[\r\n\\begin{aligned}\r\n\\begin{cases}\r\nQ_t^D = 130 - 20p_t \\\\\r\nQ_t^O = 10 + 10p_{t-1}\r\n\\end{cases}\r\n\\end{aligned}\r\n\\]\r\nO equilíbrio ocorre quando o preço for constante, \\(p_t = p_{t-1} = p\\). Além disso, o equilíbrio ocorre quando a demanda e a oferta se igualam:\r\n\\[\r\n\\begin{aligned}\r\n& Q_t^O = Q_t^D \\\\\r\n& 10 + 10p = 130 -20p \\\\\r\n& 30p = 120 \\\\\r\n& p = 4 \\\\[10pt]\r\n& Q = 10 + 10(4) = 130 - 20(4) \\\\\r\n& Q = 50\r\n\\end{aligned}\r\n\\]\r\nPorém, partindo de uma valor inicial \\(p \\ne 4\\), o modelo não se encontra em equilíbrio, sendo necessário analisar a sua dinâmica. Para tanto, manteremos os subscritos de \\(p\\) nas equações:\r\n\\[\r\n\\begin{aligned}\r\n\\begin{cases}\r\nQ_t^D = 130 - 20p_t \\\\\r\nQ_t^O = 10 + 10p_{t-1}\r\n\\end{cases}\r\n\\end{aligned}\r\n\\]  \r\n\\[\r\n\\begin{aligned}\r\n& Q_t^O = Q_t^D \\\\\r\n& 10 + 10p_{t-1} = 130 -20p_t \\\\\r\n& 20p_t + 10p_{t-1} = 120 \\\\\r\n& p_t + \\frac{1}{2}p_{t-1} = 6\r\n\\end{aligned}\r\n\\]\r\nAo encontrar o equilíbrio, encontrou-se já uma solução particular para a equação não-homogênea. Vamos encontrar agora a função complementar:\r\n\\[\r\n\\begin{aligned}\r\n& p_t + \\frac{1}{2}p_{t-1} = 0 \\\\\r\n& p_t = - \\frac{1}{2}p_{t-1} \\\\[10pt]\r\n& p_t = C(\\theta)^t \\\\\r\n& p_t = C(- \\frac{1}{2})^t\r\n\\end{aligned}\r\n\\]\r\ncomo \\(-1 < \\theta < 0\\), a solução é convergente e oscilatória.\r\nSolução geral (utilizando a solução particular de equilíbrio):\r\n\\[\r\n\\begin{aligned}\r\n& p_t = C(- \\frac{1}{2})^t + 4\r\n\\end{aligned}\r\n\\]\r\nDigamos que a condição inicial é \\(p_0 = 2\\):\r\n\\[\r\n\\begin{aligned}\r\n& p_0 = C(- \\frac{1}{2})^0 + 4 = 2 \\\\\r\n& C = -2 \\\\\r\n\\end{aligned}\r\n\\]\r\nA solução final fica:\r\n\\[\r\n\\begin{aligned}\r\n& p_t = 4 - 2(- \\frac{1}{2})^t \\\\\r\n& p_{t-1} = 4 - 2(- \\frac{1}{2})^{t-1} = 4 + 4(- \\frac{1}{2})^t \\\\[10pt]\r\n& Q_t^D = 130 - 20p_t \\\\\r\n& Q_t^D = 130 - 20[4 - 2(- \\frac{1}{2})^t] \\\\\r\n& Q_t^D = 50 + 40(- \\frac{1}{2})^t \\\\[10pt]\r\n& Q_t^O = 10 + 10p_{t-1} \\\\\r\n& Q_t^O = 10 + 10[4 + 4(- \\frac{1}{2})^t] \\\\\r\n& Q_t^O = 50 + 40(- \\frac{1}{2})^t \\\\\r\n\\end{aligned}\r\n\\]\r\nComo está sendo utilizado a solução particular do equilíbrio, \\(Q_t^O = Q_t^D\\).\r\nComo já mencionado, o equilíbrio ocorre em \\(p = 4\\), com \\(Q^O = Q^D = 50\\), e a solução é convergente e oscilatória. Vejamos essa dinâmica em gráficos:\r\n\r\n\r\n\r\n\r\n\r\n\r\nModelo de Harrod\r\nEsse é um modelo macroeconômico que relaciona poupança, investimento e crescimento.\r\nA poupança é uma parcela da renda passada, e é dada pela função:\r\n\\[\r\n\\begin{aligned}\r\n& S_t = sY_{t-1}\r\n\\end{aligned}\r\n\\]\r\nO investimento é proporcional ao aumento da renda, e é dado pela função:\r\n\\[\r\n\\begin{aligned}\r\n& I_t = k(Y_t - Y_{t-1})\r\n\\end{aligned}\r\n\\]\r\nO modelo parte do pressuposto de que o investimento é igual a poupança:\r\n\\[\r\n\\begin{aligned}\r\n& S_t =  I_t \\\\\r\n& sY_{t-1} = k(Y_t - Y_{t-1}) \\\\\r\n& kY_t - (k + s)Y_{t-1} = 0 \\\\\r\n& Y_t = \\frac{k + s}{k}Y_{t-1}\r\n\\end{aligned}\r\n\\]\r\nEssa é uma equação em diferença homogênea. Como \\(\\theta = \\frac{k + s}{k}\\) só pode ser positivo e maior que \\(1\\), a solução é não oscilatória e divergente. Portanto, não há uma renda de equilíbrio, e essa cresce indefinidamente.\r\nDigamos que \\(k\\) e \\(s\\) sejam tais que:\r\n\\[\r\n\\begin{aligned}\r\n& S_t =  0.25Y_{t-1} \\\\\r\n& I_t = 0.5(Y_t - Y_{t-1}) \\\\[10pt]\r\n& Y_t = \\frac{0.5 + 0.25}{0.5}Y_{t-1} \\\\\r\n& Y_t = \\frac{3}{2}Y_{t-1} \\\\\r\n\\end{aligned}\r\n\\]\r\nVejamos essa dinâmica no gráfico:\r\n\r\n\r\n\r\nConclusão\r\nComo visto, a solução geral de uma equação em diferença de primeira ordem é\r\n\\[\r\n\\begin{aligned}\r\n& x_t = x_c + x_p \\\\\r\n\\end{aligned}\r\n\\]\r\nEm que\r\n\\[\r\n\\begin{aligned}\r\n& x_c = C(\\theta)^t \\\\\r\n\\end{aligned}\r\n\\]\r\nSendo que\r\n\\(\\theta > 1\\): solução explosiva, não oscilatória.\r\n\\(0 < \\theta < 1\\): solução convergente, não oscilatória.\r\n\\(-1 < \\theta < 0\\): solução convergente, oscilatória.\r\n\\(\\theta < -1\\): solução explosiva, oscilatória.\r\nE\r\n\\[\r\n\\begin{aligned}\r\n& x_p =  \r\n\\begin{cases}\r\nA \\\\\r\nAt \\\\\r\nAt + B\r\n\\end{cases}\\\\\r\n\\end{aligned}\r\n\\]\r\nPrimeira Ordem App\r\nUtilize o aplicativo abaixo para experimentar diferentes configurações da equação de primeira ordem.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nNEUSSER, K. Difference equations for economists. Unpublished manuscript, October, v. 3, 2016. \r\n\r\n\r\nSARTORIS, A. Equação a diferenças de 1a ordem, não homogênea. Disponível em: <https://www.youtube.com/watch?v=YVZKn3ANUbc>. \r\n\r\n\r\n___. Aplicações de equações a diferenças de 1a ordem. Disponível em: <https://www.youtube.com/watch?v=KqKDOBtoeU4>. \r\n\r\n\r\nWAINWRIGHT, K.; CHIANG, A. C. Fundamental methods of mathematical economics. Traducao. [s.l.] Boston, Mass.: McGraw-Hill/Irwin, 2005. \r\n\r\n\r\n\r\n\r\n",
    "preview": "posts/2021-01-06-primordem/primordem_files/figure-html5/unnamed-chunk-1-1.png",
    "last_modified": "2021-01-29T23:17:43-03:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "posts/2020-12-31-eqdiff/",
    "title": "Equações em Diferença",
    "description": "Este Post apresenta uma introdução ao estudo de Equações em Diferença.",
    "author": [
      {
        "name": "Rafael Peixoto",
        "url": {}
      }
    ],
    "date": "2021-01-06",
    "categories": [
      "Introdução",
      "Matemática"
    ],
    "contents": "\r\n\r\nContents\r\nDefinição\r\nHomogeneidade\r\nSolução\r\nEstabilidade\r\nConclusão\r\n\r\nDefinição\r\nA equação em diferença descreve a evolução de alguma variável (ou grupo de variáveis) ao longo do tempo. O valor dessa variável no período \\(t\\) é denotado por \\(x_t\\). O índice de tempo \\(t\\) assume valores discretos e tipicamente abrange todos os números inteiros, ou seja, \\(t = \\dots, -2, -1, 0, 1, 2, \\dots\\).\r\nUma equação em diferença, então, nada mais é que uma regra uma função que indica como computar o valor da variável de interesse no próximo período, e.g. \\(t+1\\), dado seu valor presente, \\(t\\), ou passado, e.g. \\(t-1\\). Em sua forma mais geral, uma equação em diferença pode ser ecrita como:\r\n\\[\r\nF(x_{t+1}, x_t, x_{t-1}, \\dots, x_{t-p+1}, t) = 0\r\n\\]\r\nOnde \\(F\\) é uma função dada.\r\nHomogeneidade\r\nSe o tempo não aparece como um argumento separado e entra somente como um índice da variável, a equação é dita autônoma ou homogênea. No caso de equações de primeira ordem, por exemplo, a forma geral é \\[\\theta_1 x_t + \\theta_0x_{t-1} = g(t)\\] A equação homogênea seria\r\n\\[\\theta_1 x_t + \\theta_0x_{t-1} = 0\\]\r\nEscrita de outra forma:\r\n\\[x_{t} = f(x_{t-1})\\]\r\nSolução\r\nA partir disso, dado algum valor inicial para \\(x\\) no período \\(0\\), a equação em diferença determina, unicamente, todos os valores subsequentes de \\(x_t\\), com \\(t=1,2,\\dots\\), inserindo os valores de \\(x_t\\) iterativamente na equação. No caso da equação de primeira ordem homogênea, como apontada acima:\r\n\\[\r\n\\begin{align}\r\n& x_0 = x \\\\\r\n& x_1 = f(x_0) = f(x) \\\\\r\n& x_2 = f(x_1) = f(f(x)) = f^2(x) \\\\\r\n& \\dots \\\\\r\n& x_t = f(x_{t-1}) = f^t(x)\r\n\\end{align}\r\n\\]\r\nAssim, o valor da variável \\(x\\) no período \\(t\\) é uma função do seu valor inicial. Para explicitar essa dependência, escreve-se \\(x_t = \\phi(t,x)\\). Como resultado dessa iteração, a equação em diferença gera uma sequência, em \\(t = 0, 1, 2, \\dots\\), chamada de trajetória. O conjunto de valores realizados por uma trajetória particular é chamada de órbita.\r\n\r\n\r\n\r\nPara selecionar uma solução única para a equação em diferença, requerimentos adicionais são necessários, como as condições de fronteira. No exemplo acima, foi fornecido um valor inicial para a variável, o que o enquadra em uma condição de valor inicial. Se as condições de fronteira são suficientes para fixar uma única solução, o modelo (baseado em equações em diferença) é dito determinado.\r\nEstabilidade\r\nUsualmente, não é de interesse apenas umas descrição da evolução da variável dependente ao longo do tempo, mas também algumas propriedades qualitativas das soluções. Em particular, é importante caracterizar o comportamento de longo-prazo, ou assimptótico, da variável.\r\nUm ponto fixo de uma função \\(f\\) é um número \\(x^*\\) que quando aplicado na função resulta nele mesmo, ou seja, \\(x^* = f(x^*, t)\\). Posto de outra forma, é um número que não muda quando iterado na função. Assim, a órbita de \\(x^*\\) consiste apenas de \\(x^*\\).\r\nUm ponto fixo é estável, ou atrator, se pontos pertos dele convergem para o ponto fixo quando são iterados. Por outro lado, um ponto fixo é instável, ou repulsor, se pontos perto dele divergem do ponto fixo quando são iterados.\r\nExemplo 1: seja a equação em diferença \\(x_t = x_{t-1}^2\\). A função \\(f(x) = x^2\\) apresenta dois pontos fixos: \\(0\\) e \\(1\\). O que é fácil de se verificar: \\[\r\n\\begin{align}\r\n& x = f(x) \\\\\r\n& x = x^2 \\\\\r\n& x - x^2 = 0 \\\\\r\n& x(1 - x) = 0 \\\\\r\n& x = 0 ; \\ x = 1\r\n\\end{align}\r\n\\]\r\nO gráfico abaixo mostra quatro iterações da equação \\(x_t = x_{t-1}^2\\), para \\(x_0\\) igual a 0; 1; 1.1; -1.2; 0.9.\r\n\r\n\r\n\r\nÉ possível observar que \\(x\\) se mantém constante para \\(x_0 = 0\\) e \\(x_0 = 1\\). Além disso, para valores de \\(x_0\\) entre \\(0\\) e \\(1\\), como \\(0.9\\), \\(x\\) tende ao ponto fixo \\(0\\); e para valores fora desse intervalo \\(x\\) tente ao infinito. Considerando apenas números positivos, é possivel afirmar que \\(x = 0\\) é um ponto fixo estável, pois conforme se escolhe um \\(x_0\\) cada vez mais longe de \\(0\\), \\(x\\) sempre irá tender a \\(0\\), até que se chegue em \\(x_0 = 1\\). A partir daí, conforme se escolhe um \\(x_0\\) maior que \\(1\\), \\(x\\) tenderá sempre a se afastar desse ponto fixo, portanto \\(x = 1\\) é um ponto fixo instável.\r\n\r\n\r\n\r\n\r\nExemplo 2: seja a equação em diferença \\(x_t = \\frac{1}{2}x_{t-1} - 4\\). A função \\(f(x) = \\frac{1}{2}x - 4\\) apresenta quais pontos fixos?\r\n\\[\r\n\\begin{align}\r\n& x = f(x) \\\\\r\n& x = \\frac{1}{2}x - 4 \\\\\r\n& \\frac{1}{2}x = -4 \\\\\r\n& x = -8 \\\\\r\n\\end{align}\r\n\\]\r\nVejamos no gráfico:\r\n\r\n\r\n\r\nÉ possível observar que \\(x\\) se mantém constante para \\(x_0 = -8\\). Além disso, para valores de \\(x_0\\) tanto maiores quanto menores a \\(-8\\), \\(x\\) tende ao ponto fixo \\(-8\\). Portanto, este é um ponto fixo estável.\r\n\r\n\r\n\r\n\r\nExemplo 3: seja a Equação Logística \\(x_t = m \\times x_{t-1} \\times (1 - x_{t-1})\\). A função \\(f(x) = m \\times x \\times (1 - x)\\) apresenta quais pontos fixos?\r\n\\[\r\n\\begin{align}\r\n& x = f(x) \\\\\r\n& x = mx(1 - x) \\\\\r\n& mx(1 - x) - x = 0 \\\\\r\n& x(m - mx - 1) = 0 \\\\\r\n& x = 0 ; \\ x = 1 - \\frac{1}{m} \\\\\r\n\\end{align}\r\n\\]\r\nVejamos o gráfico para m = 2:\r\n\r\n\r\n\r\nÉ possível observar que \\(x\\) se mantém constante para \\(x_0 = 0\\) e \\(x_0 = 0.5\\). Além disso, para valores de \\(x_0\\) tanto maiores quanto menores a \\(0.5\\), \\(x\\) tende ao ponto fixo \\(0.5\\). Portanto, este é um ponto fixo estável.Já \\(x_0 = 0\\) é um ponto fixo instável, pois conforme \\(x\\) se afasta dele, até \\(x = 0.5\\), mais ele tende a se afastar, em direção àqele ponto fixo. Fora do intervalo \\([0,1]\\) a equação explode.\r\n\r\n\r\n\r\n\r\nVejamos o gráfico para m = 3:\r\n\r\n\r\n\r\nÉ possível observar que \\(x\\) se mantém constante para \\(x_0 = 0\\) e \\(x_0 = 0.666\\). Além disso, para valores de \\(x_0\\) tanto maiores quanto menores a \\(0.666\\), \\(x\\) tende a oscilar entre esse ponto. Como visto acima, esses são os pontos fixos da equação:\r\n\\[\r\n\\begin{align}\r\n& x = 0 ; \\ x = 1 - \\frac{1}{m} \\\\\r\n\\end{align}\r\n\\]\r\nPara \\(m = 3\\), o segundo ponto fixo é \\(1 - \\frac{1}{3}\\), aproximadamente \\(0.666\\). Para valores de \\(x_0\\) diferentes dos dois pontos fixos, a iteração da equação gera um ciclo atrator, a óbita é periódica. Diferentes valores de \\(m\\), entre \\(3\\) e \\(4\\) (excluso), geram ciclos atratores com diferentes períodos (número de interações para se repetir um ciclo).\r\nVejamos o gráfico para m = 4:\r\n\r\n\r\n\r\nÉ possível observar que \\(x\\) se mantém constante para \\(x_0 = 0\\) e \\(x_0 = 0.75\\) (segundo ponto fixo). Já para os valores de \\(x_0\\) tanto maiores quanto menores a \\(0.75\\), \\(x\\) tende a oscilar de forma aperiódica, ou seja, a óbita é aperiódica.\r\nApesar de a Equação Logística ser determinística, como as órbitas são aperiódicas para \\(m = 4\\), variações pequenas no \\(x_0\\) levam a trajetórias completamente distintas, o que torna impraticável a previsão de \\(x\\) após um certo número de iterações. Tal comportamento é denominado de dependência sensível das condições iniciais (sensitive dependence on initial conditions (SDIC)). Posto de outra forma, um sistema dinâmico possui dependência sensível das condições iniciais se diferenças arbitrariamente pequenas nas condições iniciais eventualmente levam a diferenças arbitrariamente grandes nas órbitas.\r\nEsse comportamento é bem visível quando se parte de \\(x_0\\) muito próximos:\r\n\r\n\r\n\r\nAté o período \\(14\\), as órbitas se comportam de forma muito semelhante, mas as diferenças vão se acumulando a cada iteração, fazendo com que a partir deste período as órbitas se divirjam enormemente. Caso isso fosse um exercício de previsão, um ‘erro’ de \\(0.00001\\) no valor inicial faria com que essa previsão fosse errônea a partir do período \\(14\\). Esse comportamento é denominado também de efeito borboleta.\r\nLogistic App\r\nUtilize o aplicativo abaixo para experimentar diferentes configurações da equação logística.\r\n\r\n\r\n\r\n\r\nConclusão\r\nEssa breve introdução buscou apresentar o conceito de equações em diferença e algumas de suas características principais. O foco se deu sobre o comportamento ao longo do tempo desse tipo de equação. Como visto, a órbita produzida por uma sequência de iterações de uma equação em diferença pode apresentar diversos comportamentos:\r\nPonto fixo\r\nAtraído por um ponto fixo\r\nExplosivo\r\nCiclo periódico\r\nCiclo aperiódico\r\nEsses comportamentos dependem tanto da estrutura da equação em si como do valor inicial \\(x_0\\).\r\n\r\n\r\n\r\nNEUSSER, K. Difference equations for economists. Unpublished manuscript, October, v. 3, 2016. \r\n\r\n\r\nWAINWRIGHT, K.; CHIANG, A. C. Fundamental methods of mathematical economics. Traducao. [s.l.] Boston, Mass.: McGraw-Hill/Irwin, 2005. \r\n\r\n\r\n\r\n\r\n",
    "preview": "posts/2020-12-31-eqdiff/eqdiff_files/figure-html5/unnamed-chunk-1-1.png",
    "last_modified": "2021-01-27T15:12:35-03:00",
    "input_file": {},
    "preview_width": 360,
    "preview_height": 193
  }
]
