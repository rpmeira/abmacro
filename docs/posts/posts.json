[
  {
    "path": "posts/2021-03-27-distriq/",
    "title": "Modelo - Distribuição de Riqueza",
    "description": "Esse texto descreve e analisa o modelo baseado em agentes \"Money Model\". Esse modelo é proposto como um tutorial ao módulo de Python para ABMs, o **Mesa**, em https://mesa.readthedocs.io/en/stable/tutorials/intro_tutorial.html. Aqui porém, o modelo é implementado em LSD, e são acrescentadas modificações importantes, como a inclusão de um agente representando o governo.",
    "author": [
      {
        "name": "Rafael Peixoto",
        "url": {}
      }
    ],
    "date": "2021-04-21",
    "categories": [
      "Modelos",
      "LSD"
    ],
    "contents": "\r\n\r\nContents\r\nIntrodução\r\nModelo\r\nEstrutura do modelo\r\n\r\nEquações\r\nAnálise de Sensibilidade\r\nConclusão\r\n\r\n\r\n\r\nd-article p {\r\n  text-align: justify;\r\n  font-size: 16px;\r\n}\r\n\r\nd-article p code {\r\n  background: rgba(236, 236, 236, 0.8);\r\n}\r\n\r\nd-article div.sourceCode {\r\n  overflow: auto !important;\r\n}\r\n\r\nIntrodução\r\nEsse modelo se baseia no artigo de Drǎgulescu e Yakovenko (2003) em que os autores comparam o equilíbrio da mecânica estatística com o ‘equilíbrio’ das transações monetárias entre os agentes. Em toda transação, o dinheiro é transferido de um agente para o outro, porém a quantidade total de dinheiro é conservada. No modelo aqui analisado, porém, ao invés dos agentes transacionarem dinheiro entre si, eles pagam um imposto ao governo e esse, por sua vez, distribui todo o dinheiro arrecadado entre os agentes (escolhendo-os de forma aleatória). Mantém-se a condição de que a quantidade inicial de dinheiro é igual para todos os agentes, e a de que os agentes só transferem dinheiro caso possuam no mínimo 1 unidade deste. O objetivo do modelo é observar a distribuição do dinheiro entre os agentes e a forma como essa muda ao longo do tempo. Para calcular essa distribuição, utiliza-se o índice de Gini, que mede o grau de concentração de renda.\r\nModelo\r\nO modelo é composto por um número N de agentes que, em cada período, transferem uma unidade de dinheiro (caso tenham), wealth, para o governo, ou seja, pagam uma Tax. O governo, por sua vez, distribui todo o dinheiro assim arrecado entre os agentes, ou seja, pagam uma assistência, Assist para esses (escolhidos de forma aleatória). Adicionalmente, o modelo computada, em cada período, o Índice de Gini, gini, a partir da seguinte fórmula:\r\n\\[\\begin{equation}\r\ngini = \\frac{2}{n^2\\bar{x}}\\sum_{i=1}^ni(x_i-\\bar{x}) \\tag{1}\r\n\\end{equation}\\]\r\nonde \\(x_i\\) é a wealth de cada agente \\(i\\), \\(\\bar{x}\\) é a média, e essas riquezas estão enumeradas de forma ascendente.\r\nEstrutura do modelo\r\nO modelo, no LSD, possui a seguinte estrutura (de objetos, ou agentes):\r\n\r\n\r\n\r\nO Mundo é o objeto origem, do qual descendem os objetos Agente e Governo.\r\nCada um dos objetos contêm um conjunto de variáveis e parâmetros (cujos valores podem variar para cada cópia do objeto):\r\n\r\n\r\nVariável\r\nParâmetro\r\nMundo\r\nInitGiniAvgInitAssistInitTaxTotalWealth\r\nNInitWealthRedistribInitFiscal\r\nAgente\r\nWealthProbTax\r\nIdAgenteIncome\r\nGoverno\r\nFiscalAssist\r\nGovIncome\r\n\r\nVejamos como é implementada cada Equação para essas variáveis, juntamente com os parâmetros necessários.\r\nEquações\r\nO modelo inteiro é constituído por 11 equações (11 variáveis). Dessas, as equações de Init, InitAssist, InitTax, Tax e Assist retornam sempre o valor 1, sendo sua finalidade configurar alguns parâmetros e variáveis. A variável Gini é a de maior interesse do modelo, pois indica a concentração de renda entre os agentes. As variáveis Avg e TotalWealth servem para indicar que o modelo está se comportando como planejado, ou seja, mantendo inalterado a riqueza total e a “per capita”. A variável Wealth computa qual a riqueza de cada agente, sendo que em cada período essa riqueza pode aumentar ou diminuir, a depender se o agente doa ou recebe (e quanto) riqueza. A variável Prob computa a probabilidade de cada agente em ser escolhido para receber uma doação de riqueza, sendo que essa probabilidade é inversamente proporcional à sua riqueza — no caso em que o parâmetro Redistrib for ajustado para 1 (caso seja zero, todas as Prob são iguais). A variável Fiscal computa a riqueza do Governo, após receber os impostos e pagar a assistência.\r\n\r\n//#define EIGENLIB          // uncomment to use Eigen linear algebra library\r\n//#define NO_POINTER_INIT   // uncomment to disable pointer checking\r\n#include \"fun_head_fast.h\"\r\n// do not add Equations in this area\r\nMODELBEGIN\r\n// insert your equations here, between the MODELBEGIN and MODELEND words\r\n\r\nEQUATION(\"Init\")\r\n/*\r\nModel initialization\r\n*/\r\nv[0] = V(\"N\");\r\nv[1] = COUNT(\"Agente\");\r\nfor (i = v[1]; i < v[0]; ++i)\r\n    ADDOBJL(\"Agente\", 0);             // add missing objects\r\nv[2] = 0;\r\nv[3] = V(\"InitWealth\");\r\nCYCLE(cur, \"Agente\")\r\n{\r\n    v[2]++;\r\n    WRITELS(cur, \"Wealth\", v[3], 0);\r\n    WRITELS(cur, \"IdAgente\", v[2], 0);\r\n    WRITELS(cur, \"Prob\", 1, 0);\r\n    WRITELS(cur, \"Income\", 0, 0);\r\n}\r\nv[4] = V(\"InitFiscal\");\r\ncur1 = SEARCH(\"Governo\");\r\nWRITELS(cur1, \"Fiscal\", v[4], 0);\r\nWRITELS(cur1, \"GovIncome\", 0, 0);\r\nPARAMETER;\r\nRESULT(1)\r\n\r\n\r\nEQUATION(\"Prob\")\r\n/*\r\nCompute Agent's probability of being chosen to receive wealth\r\n*/\r\nv[0] = VL(\"Wealth\", 1);\r\nv[1] = V(\"Redistrib\");\r\nif (v[1] == 0)\r\n    v[2] = 1;\r\nelse\r\n{\r\n    if (v[0] == 0)\r\n        v[2] = 1;\r\n    else\r\n        v[2] = 1 / v[0];\r\n}\r\nRESULT(v[2])\r\n\r\n\r\nEQUATION(\"InitAssist\")\r\n/*\r\nComment\r\n*/\r\nCYCLE(cur, \"Agente\")\r\n    WRITES(cur, \"Income\", 0);\r\nRESULT(1)\r\n\r\n\r\nEQUATION(\"InitTax\")\r\n/*\r\nComment\r\n*/\r\ncur = SEARCH(\"Governo\");\r\nWRITES(cur, \"GovIncome\", 0);\r\nRESULT(1)\r\n\r\n\r\nEQUATION(\"Tax\")\r\n/*\r\nTax payment by agents\r\n*/\r\nV(\"InitTax\");\r\nV(\"InitAssist\");\r\nv[0] = VL(\"Wealth\", 1);\r\nif (v[0] > 0)\r\n{\r\n    cur = SEARCHS(PARENT, \"Governo\");\r\n    INCRS(cur, \"GovIncome\", 1);\r\n    INCR(\"Income\", -1);\r\n}\r\nRESULT(1)\r\n\r\n\r\nEQUATION(\"Assist\")\r\n/*\r\nAssist payment to agents, by governmnet\r\n*/\r\nv[0] = VL(\"Fiscal\", 1);\r\nwhile (v[0] > 0)\r\n{\r\n    cur = RNDDRAWS(PARENT, \"Agente\", \"Prob\");\r\n    INCRS(cur, \"Income\", 1);\r\n    INCR(\"GovIncome\", -1);\r\n    v[0]--;\r\n}\r\nRESULT(1)\r\n\r\n\r\nEQUATION(\"Fiscal\")\r\n/*\r\nCompute Government Fiscal balance\r\n*/\r\nV(\"Assist\");\r\nCYCLES(PARENT, cur1, \"Agente\")\r\n{\r\n    VS(cur1, \"Tax\");\r\n}\r\nv[0] = CURRENT;\r\nv[1] = V(\"GovIncome\");\r\nv[2] = v[0] + v[1];\r\nRESULT(v[2])\r\n\r\n\r\nEQUATION(\"Wealth\")\r\n/*\r\nCompute each agent's wealth\r\n*/\r\nCYCLES(PARENT, cur1, \"Agente\")\r\n{\r\n    VS(cur1, \"Tax\");\r\n}\r\nVS(PARENT, \"Assist\");\r\nv[0] = CURRENT;\r\nv[1] = V(\"Income\");\r\nv[2] = v[0] + v[1];\r\nRESULT(v[2])\r\n\r\n\r\nEQUATION(\"Gini\")\r\n/*\r\nComment\r\n*/\r\nSORT(\"Agente\", \"Wealth\", \"UP\");\r\nv[0] = 0;\r\nv[1] = AVE(\"Wealth\");\r\nv[2] = 0;\r\nif (T == 1)\r\n{\r\n    v[6] = 0.01;\r\n}\r\nelse\r\n{\r\n CYCLE(cur, \"Agente\")\r\n {\r\n    v[2]++;\r\n    v[3] = VS(cur, \"Wealth\");\r\n    v[4] = v[2] * (v[3] - v[1]);\r\n    v[0] = v[0] + v[4];\r\n }\r\n        v[5] = V(\"N\");\r\n        v[6] = v[0] * (2 / (v[1] * v[5] * v[5]));\r\n}\r\nRESULT(v[6])\r\n\r\n\r\nEQUATION(\"Avg\")\r\n/*\r\nAverage Wealth\r\n*/\r\nv[0] = SUM(\"Wealth\");\r\nv[1] = V(\"N\");\r\nv[2] = v[0] / v[1];\r\nRESULT(v[2])\r\n\r\n\r\nEQUATION(\"TotalWealth\")\r\n/*\r\nWorld's total wealth\r\n*/\r\nv[0] = SUM(\"Wealth\");\r\nv[1] = V(\"Fiscal\");\r\nv[2] = v[0] + v[1];\r\nRESULT(v[2])\r\n\r\n\r\nMODELEND\r\n// do not add Equations in this area\r\nvoid close_sim( void )\r\n{\r\n    // close simulation special commands go here\r\n}\r\n\r\nVamos analisar cada um dessas equações com mais detalhes. Lembrando que os modelos escritos no LSD são compostos por um conjunto de Equações que são atualizadas em cada período de uma simulação. Essas equações descrevem o comportamento das variáveis (ou funções) que fazem parte do modelo. Em todos os casos abaixo, o parâmetro N está ajustado para 100, a menos que indicado de outra forma.\r\nEQUATION(“Init”)\r\nEssa equação tem como finalidade inicializar o modelo. Mais especificamente, ela cria uma quantidade de cópias do objeto “Agente” igual ao número estabelecido pelo parâmetro N — a macro ADDOBJL(\"Agente\", 0) estabelece o período 0 para a criação desses agentes. Para cada uma dessas cópias, inicializa as variáveis Wealth — para o valor do parâmetro InitWealth — e Prob — para 1 —, além dos parâmetros IdAgente e Income. Além disso, inicializa, para o agente Governo, a variável Fiscal e o parâmetro GovIncome. No final, a equação transforma a variável Init em um parâmetro.\r\n\r\nEQUATION(\"Init\")\r\n/*\r\nModel initialization\r\n*/\r\nv[0] = V(\"N\");\r\nv[1] = COUNT(\"Agente\");\r\nfor (i = v[1]; i < v[0]; ++i)\r\n    ADDOBJL(\"Agente\", 0); \r\nv[2] = 0;\r\nv[3] = V(\"InitWealth\");\r\nCYCLE(cur, \"Agente\")\r\n{\r\n    v[2]++;\r\n    WRITELS(cur, \"Wealth\", v[3], 0);\r\n    WRITELS(cur, \"IdAgente\", v[2], 0);\r\n    WRITELS(cur, \"Prob\", 1, 0);\r\n    WRITELS(cur, \"Income\", 0, 0);\r\n}\r\nv[4] = V(\"InitFiscal\");\r\ncur1 = SEARCH(\"Governo\");\r\nWRITELS(cur1, \"Fiscal\", v[4], 0);\r\nWRITELS(cur1, \"GovIncome\", 0, 0);\r\nPARAMETER;\r\nRESULT(1)\r\n\r\nEQUATION(“Prob”)\r\nEssa equação tem como finalidade computar uma variável que servirá de proporção para a probabilidade de um agente ser escolhido pelo governo para receber uma unidade de riqueza. Caso o parâmetro Redistrib seja ajustado para 0, todos os agentes possuem a mesma probabilidade de serem escolhidos, uma vez a variável Prob será igual a 1 para todos. Caso Redistrib seja diferente de 0: \\(\\small Prob = \\frac{1}{Wealth}\\), a menos que Wealth seja zero, caso em que \\(\\small Prob = 1\\).\r\n\r\nEQUATION(\"Prob\")\r\n/*\r\nCompute Agent's probability of being chosen to receive wealth\r\n*/\r\nv[0] = VL(\"Wealth\", 1);\r\nv[1] = V(\"Redistrib\");\r\nif (v[1] == 0)\r\n    v[2] = 1;\r\nelse\r\n{\r\n    if (v[0] == 0)\r\n        v[2] = 1;\r\n    else\r\n        v[2] = 1 / v[0];\r\n}\r\nRESULT(v[2])\r\n\r\nVejamos alguns exemplos do comportamento dessa variável (lembrando que \\(\\small N=100\\)). Vale ressaltar aqui que essa variável não indica a probabilidade estatística de o agente ser escolhido, ela é um valor de referência para o cálculo das probabilidades.\r\n\\[\r\n\\small\r\nP(Agente) = \\frac{Prob_{Agente}}{\\sum Prob}\r\n\\]\r\nCaso 1: começamos com o exemplo clássico em que cada agente começa com 1 riqueza e não há diferença nas probabilidades de ser escolhido, ou seja:\r\n\\[\r\n\\small\r\n\\begin{aligned}\r\n\\begin{cases}\r\nInitWealth = 1 \\\\\r\nRedistrib = 0\r\n\\end{cases}\\\\\r\n\\end{aligned}\r\n\\]\r\nNesse caso, a Prob de todos os agentes é simplesmente uma reta com valor 1.\r\nCaso 2: Vejamos agora o mesmo caso porém com redistribuição:\r\n\\[\r\n\\small\r\n\\begin{aligned}\r\n\\begin{cases}\r\nInitWealth = 1 \\\\\r\nRedistrib = 1\r\n\\end{cases}\\\\\r\n\\end{aligned}\r\n\\] Para facilitar a visualização, será colocado no gráfico apenas a Prob de 5 agentes.\r\n\r\n\r\n\r\nObserva-se que é muito recorrente que o agentes possuam Prob igual a 1, uma vez que é recorrente que tenham apenas 0 ou 1 de riqueza (como ficará mais claro no gráfico de riqueza mostrada mais adiante).\r\nCaso 3: Vejamos agora o caso com redistribuição, mas riqueza inicial igual a 20:\r\n\\[\r\n\\small\r\n\\begin{aligned}\r\n\\begin{cases}\r\nInitWealth = 20 \\\\\r\nRedistrib = 1\r\n\\end{cases}\\\\\r\n\\end{aligned}\r\n\\]\r\nNovamente, para facilitar a visualização, será colocado no gráfico apenas a Prob de 5 agentes.\r\n\r\n\r\n\r\nNesse caso em que os agentes começam com 20 de riqueza, se torna muito mais raro que cheguem a ter pouco dinheiro, então as Prob de cada agente ficam mais próximas uma da outra.\r\nEQUATION(“InitAssist”)\r\nEssa equação tem como finalidade inicializar a distribuição de assistência, Assist, pelo governo, em cada período. Para isso, ela ajusta para 0 a renda, Income, de cada agente, para que essa não se some à renda do período anterior. A equação sempre retorna o valor 1.\r\n\r\nEQUATION(\"InitAssist\")\r\n/*\r\nInitialize government's assistence\r\n*/\r\nCYCLE(cur, \"Agente\")\r\n    WRITES(cur, \"Income\", 0);\r\nRESULT(1)\r\n\r\nEQUATION(“InitTax”)\r\nEssa equação tem como finalidade inicializar o pagamento de impostos, Tax, pelos agentes, em cada período. Para isso, ela ajusta para 0 a renda do governo, GovIncome, para que essa não se some à do período anterior. A equação sempre retorna o valor 1.\r\n\r\nEQUATION(\"InitTax\")\r\n/*\r\nInitialize agent's tax\r\n*/\r\ncur = SEARCH(\"Governo\");\r\nWRITES(cur, \"GovIncome\", 0);\r\nRESULT(1)\r\n\r\nEQUATION(“Tax”)\r\nEssa equação tem como finalidade realizar o pagamento de impostos de cada agente. Para tanto, primeiramente ela reseta os valores das rendas dos agentes e do governo — essa é a primeira coisa que acontece em cada período. Após isso, ela busca o valor da riqueza do agente, para verificar se essa é maior que 0. Caso o agente possua riqueza, \\(\\small Wealth > 0\\), ele paga 1 de imposto para o governo, descontando da sua renda. A equação sempre retorna o valor 1.\r\n\r\nEQUATION(\"Tax\")\r\n/*\r\nTax payment by agents\r\n*/\r\nV(\"InitTax\");\r\nV(\"InitAssist\");\r\nv[0] = VL(\"Wealth\", 1);\r\nif (v[0] > 0)\r\n{\r\n    cur = SEARCHS(PARENT, \"Governo\");\r\n    INCRS(cur, \"GovIncome\", 1);\r\n    INCR(\"Income\", -1);\r\n}\r\nRESULT(1)\r\n\r\nEQUATION(“Assist”)\r\nEssa equação tem como finalidade realizar a distribuição de assistência pelo governo. Para tanto, ela busca a riqueza do governo, Fiscal, no período anterior e a distribui inteira para os agentes. A distribuição é feita de forma aleatória, com base nas probabilidades de Prob.\r\n\r\nEQUATION(\"Assist\")\r\n/*\r\nAssist payment to agents, by governmnet\r\n*/\r\nv[0] = VL(\"Fiscal\", 1);\r\nwhile (v[0] > 0)\r\n{\r\n    cur = RNDDRAWS(PARENT, \"Agente\", \"Prob\");\r\n    INCRS(cur, \"Income\", 1);\r\n    INCR(\"GovIncome\", -1);\r\n    v[0]--;\r\n}\r\nRESULT(1)\r\n\r\nEQUATION(“Fiscal”)\r\nEssa equação tem como finalidade computar a riqueza do governo, Fiscal. Para tanto, ela verifica se o governo já distribuiu a assistência e se os agentes já pagaram impostos. Feito isso, a equação busca o valor da riqueza do governo no período anterior, assim como sua renda no período corrente. O resultado retornado é simplesmente a soma desses dois valores.\r\n\r\nEQUATION(\"Fiscal\")\r\n/*\r\nCompute Government Fiscal balance\r\n*/\r\nV(\"Assist\");\r\nCYCLES(PARENT, cur1, \"Agente\")\r\n{\r\n    VS(cur1, \"Tax\");\r\n}\r\nv[0] = CURRENT;\r\nv[1] = V(\"GovIncome\");\r\nv[2] = v[0] + v[1];\r\nRESULT(v[2])\r\n\r\nVejamos alguns exemplos do comportamento dessa variável (com \\(\\small N=100\\) e \\(\\small InitFiscal=100\\)).\r\n\r\n\r\n\r\nO gráfico deixa claro que, conforme aumenta riqueza inicial dos agentes, mais perto fica da estabilidade a riqueza do governo. Isso é devido ao fato de que o governo não recebe impostos de agentes com riqueza igual a zero, porém é obrigado mesmo assim a distribuir toda a riqueza que possuía no período anterior. Portanto, quanto maior a IniWealth, menos agentes chegam a ter 0 de riqueza e portanto menos o governo precisa incorrer em deficits.\r\nEQUATION(“Wealth”)\r\nEssa equação tem como finalidade computar a riqueza, Wealth, de cada agente. Para tanto, primeiramente ela verifica se todos os agentes já pagaram impostos e se o governo ja distribuiu a assistência. Feito isso, a equação busca o valor da riqueza do agente em questão no período anterior, assim como sua renda no período corrente. O resultado retornado é simplesmente a soma desses dois valores.\r\n\r\nEQUATION(\"Wealth\")\r\n/*\r\nCompute each agent's wealth\r\n*/\r\nCYCLES(PARENT, cur1, \"Agente\")\r\n{\r\n    VS(cur1, \"Tax\");\r\n}\r\nVS(PARENT, \"Assist\");\r\nv[0] = CURRENT;\r\nv[1] = V(\"Income\");\r\nv[2] = v[0] + v[1];\r\nRESULT(v[2])\r\n\r\nVejamos alguns exemplos do comportamento dessa variável (lembrando que \\(\\small N=100\\), e que para facilitar a visualização serão mostrados nos gráficos apenas o comportamento de 5 agentes).\r\nCaso 1:\r\n\\[\r\n\\small\r\n\\begin{aligned}\r\n\\begin{cases}\r\nInitWealth = 1 \\\\\r\nRedistrib = 0\r\n\\end{cases}\\\\\r\n\\end{aligned}\r\n\\]\r\n\r\n\r\n\r\nComo cada agente começa com apenas 1 de riqueza, é muito comum em cada período haver diversos agentes com 0 de riqueza (situação em que não pagam impostos, apenas esperam ser escolhidos para receber assistência).\r\nCaso 2:\r\n\\[\r\n\\small\r\n\\begin{aligned}\r\n\\begin{cases}\r\nInitWealth = 1 \\\\\r\nRedistrib = 1\r\n\\end{cases}\\\\\r\n\\end{aligned}\r\n\\]\r\n\r\n\r\n\r\nA existência de diferentes probabilidades dos agentes serem escolhidos não altera muito a visualização do comportamento da riqueza de 5 agentes ao longo do tempo (altera mais as variáveis globais, que veremos a seguir).\r\nCaso 3:\r\n\\[\r\n\\small\r\n\\begin{aligned}\r\n\\begin{cases}\r\nInitWealth = 20 \\\\\r\nRedistrib = 1\r\n\\end{cases}\\\\\r\n\\end{aligned}\r\n\\]\r\n\r\n\r\n\r\nComo cada gente começa com 20 de riqueza, há bastante riqueza a ser distribuida e trocada, então se torna muito mais difícil (no gráfico, nenhum caso) que algum agente chegue a zero de riqueza.\r\nEQUATION(“Gini”)\r\nEssa equação tem como finalidade computar o índice de Gini, Gini. Para tanto ela computa a fórmula (1), indicada no início do texto. Inicialmente, a equação coloca em ordem crescente as Wealth de cada agente e computa a média dessa variável. Depois, a equação vai de agente em agente calculando a diferença entre a riqueza desse agente e a média, somando essas diferenças (v[0]), além de atribuir um índice crescente (de 0 a N) a cada agente de forma consecutiva, v[2], o que faz parte da fórmula. Há um condição especial nessa equação, porém, que indica que no período 1, T == 1 , o resultado a ser retornado será igual a 0.01. Isso é feito apenas para contornar o caso em que a média de riqueza dos agentes, no momento da computação dessa equação, é igual a zero (caso que ocorre quando \\(\\small InitWealth=1\\)). De toda forma, como no período 1 todos os agentes possuem riqueza igual, faz sentido associar um índice de gini baixo nesse período.\r\n\r\nEQUATION(\"Gini\")\r\n/*\r\nCompute the Gini Index\r\n*/\r\nSORT(\"Agente\", \"Wealth\", \"UP\");\r\nv[0] = 0;\r\nv[1] = AVE(\"Wealth\");\r\nv[2] = 0;\r\nif (T == 1)\r\n{\r\n    v[6] = 0.01;\r\n}\r\nelse\r\n{\r\n CYCLE(cur, \"Agente\")\r\n {\r\n    v[2]++;\r\n    v[3] = VS(cur, \"Wealth\");\r\n    v[4] = v[2] * (v[3] - v[1]);\r\n    v[0] = v[0] + v[4];\r\n }\r\n        v[5] = V(\"N\");\r\n        v[6] = v[0] * (2 / (v[1] * v[5] * v[5]));\r\n}\r\nRESULT(v[6])\r\n\r\nVejamos alguns exemplos do comportamento dessa variável.\r\n\r\n\r\n\r\nComo o gráfico mostra, tanto a riqueza inicial (InitWealth) quando a diferenciação das probabilidades de receber assistência do governo (Redistrib) possuem grande influência sobre o índice de Gini.\r\nEQUATION(“Avg”) e EQUATION(“TotalWealth”)\r\nEssas duas equações servem apenas para verificar se o modelo está sendo implementado da forma como se espera (um dos pressupostos do modelo é que a riqueza total do modelo se mantém constante).\r\nAnálise de Sensibilidade\r\nA análise de sensibilidade (SA) busca avaliar como a incerteza nos resultados das simulações pode ser atribuída a diferentes fontes de incerteza nas equações e configurações do modelo. Para o modelo analisado nesse post, será feita uma análise de sensibilidade para a variável Gini, aplicando-se o método SVD (Sobol Variance Decomposition). Mais especificamente, o SVD será aplicado sobre um meta modelo ajustado pelo método de Kriging, usando a estratégia de amostragem NOLH (Near Orthogonal Latin Hypercube). O objetivo é entender qual dos parâmetros (N, InitWealth e Redistrib, InitFiscal) possui maior impacto sobre o resultado do modelo.\r\n\r\n\r\n\r\nComo é possível observar no gráfico, a redistribuição da riqueza, Redistrib — que altera as probabilidades de os agentes serem escolhidos para receber assistência, colocando maior peso nos agentes com menor riqueza —, é o parâmetro que mais afeta o comportamento do índice de Gini, Gini, no modelo. Em segundo lugar está a riqueza inicial dos agentes, InitWealth. Em terceiro, a riqueza inicial do governo, InitFiscal, com efeitos de interação apenas. E em último lugar está o número de agentes, N, que praticamente não possui influência sobre o índice de Gini, nesse modelo.\r\nA partir do meta modelo é possível, também, criar um gráfico que infira o resultado da variável de interesse, Gini, a partir de combinações de parâmetros (no caso, os dois que mais influenciam nesse resultado, Redistrib e InitWealth).\r\n\r\n\r\n{\"x\":{\"visdat\":{\"47cc6a8054dc\":[\"function () \",\"plotlyVisDat\"]},\"cur_data\":\"47cc6a8054dc\",\"attrs\":{\"47cc6a8054dc\":{\"x\":[2,6.08333333333333,10.1666666666667,14.25,18.3333333333333,22.4166666666667,26.5,30.5833333333333,34.6666666666667,38.75,42.8333333333333,46.9166666666667,51,55.0833333333333,59.1666666666667,63.25,67.3333333333333,71.4166666666667,75.5,79.5833333333333,83.6666666666667,87.75,91.8333333333333,95.9166666666667,100],\"y\":[0,0.0416666666666667,0.0833333333333333,0.125,0.166666666666667,0.208333333333333,0.25,0.291666666666667,0.333333333333333,0.375,0.416666666666667,0.458333333333333,0.5,0.541666666666667,0.583333333333333,0.625,0.666666666666667,0.708333333333333,0.75,0.791666666666667,0.833333333333333,0.875,0.916666666666667,0.958333333333333,1],\"z\":[[0.388262322816563,0.376316887303776,0.353156156004885,0.322237148486835,0.287358157061879,0.251810521700873,0.218621665708493,0.190108279623754,0.166408685223166,0.147291113409194,0.133128870094527,0.124198465051999,0.119817937453002,0.118932384211412,0.12043135678734,0.123482491774631,0.127476292968063,0.131972781823104,0.136660148394827,0.141322808297304,0.145816816922902,0.150051025376197,0.153972706139481,0.15755664864865,0.160796940303524],[0.35322082066132,0.343315907882724,0.324111510980069,0.298474119741685,0.269553196741471,0.240077850038538,0.212558353535479,0.188915657441117,0.169264455483964,0.153412569519333,0.141669536984761,0.134264634552578,0.13063239536739,0.129898115904394,0.131141035345244,0.133670975283751,0.136982554164927,0.140710950953946,0.144597619353392,0.148463801297473,0.152190140933435,0.155701059513538,0.158952836495678,0.16192456782163,0.164611350901767],[0.298543587694381,0.291822613100984,0.278791503616829,0.261395313148445,0.241771098388973,0.221770684829425,0.203097408559878,0.1870547237089,0.173720455926999,0.162964203012795,0.15499600089945,0.149971426039785,0.147506783912128,0.147008546406744,0.147851932960481,0.149568624298223,0.151815694723895,0.154345595633355,0.15698289095521,0.159606284777927,0.162134788452271,0.164517118201559,0.166723607573487,0.168740072195937,0.170563185460621],[0.254448205755727,0.250294947660128,0.242242367141481,0.231492416137025,0.219365678209397,0.207006477337741,0.195467378672112,0.185553845542703,0.177313971240107,0.170667173529774,0.165743243912093,0.16263832339778,0.16111531199395,0.160807439589077,0.161328622849318,0.162389463772683,0.163778051387687,0.165341413043914,0.166971138061883,0.168592271693594,0.170154767075037,0.171626933473409,0.172990438582497,0.174236517245658,0.175363113857667],[0.224866387107936,0.222435652285015,0.217722914577073,0.211431621223926,0.204334614042592,0.197101578008561,0.190348497194803,0.184546751568884,0.179724489350429,0.175834549870329,0.172952892407269,0.17113578813091,0.170244483978301,0.170064331136236,0.170369376265399,0.170990250700139,0.171802934735833,0.172717902064154,0.17367170606779,0.174620480053491,0.175534934541096,0.176396522877048,0.177194516349013,0.177923785357807,0.178583127021361],[0.206699421748316,0.205326419918855,0.202664658242152,0.199111465331822,0.195103294799955,0.191018333686208,0.187204439798639,0.183927820977541,0.181204379098581,0.179007477199491,0.17738001591694,0.176353787573251,0.175850441836524,0.175748748371055,0.17592108888631,0.176271804212494,0.176730848372023,0.177247657312558,0.177786396814936,0.178322291402965,0.178838798797571,0.179325444245848,0.179776168540173,0.180188074821252,0.18056048400791],[0.196108806133356,0.195352189458813,0.193885844126205,0.191928696945575,0.189721088961507,0.187471255676749,0.185370726702225,0.183566096950459,0.182066134143629,0.180856163078197,0.179959814818238,0.179394624244134,0.179117464237996,0.179061557243617,0.179156600294753,0.179349896490611,0.179602859109174,0.17988763388215,0.180184481065199,0.180479753037441,0.180764337714828,0.181032465490721,0.181280799169471,0.181507743590513,0.181712925274894],[0.190143431750378,0.189733541261098,0.188940093347863,0.187881633442623,0.186688014796013,0.185471704318722,0.184336133804456,0.183360512198925,0.182549598789288,0.181895450547326,0.181410849190638,0.181105324479732,0.180955611280741,0.180925590632483,0.180977223260788,0.181081996667211,0.181219033564063,0.18137326405914,0.181534009005713,0.181693885623151,0.181847965191306,0.181993127465367,0.182127568229552,0.182250425733274,0.182361499131796],[0.186863977921988,0.186643770664875,0.186219358839608,0.185654317097664,0.185017711281491,0.184369279752132,0.18376393707187,0.183243823676203,0.182811515235562,0.182462758690839,0.182204380585234,0.182041561152513,0.181961997916719,0.181946400428009,0.181974425763858,0.182030826896691,0.182104441062471,0.182187211853447,0.182273431312459,0.182359154460872,0.182441748697934,0.182519548452535,0.182591591767636,0.182657420487659,0.182716929667442],[0.185092907885352,0.18497329567433,0.184746419445794,0.184446590980429,0.184109954699714,0.183767614247866,0.183448112528439,0.183173525080991,0.182945288031668,0.182761119195681,0.182624647349051,0.182538805520653,0.182497298087036,0.18248987124871,0.182505658517014,0.182536517623679,0.182576490050312,0.182621277843138,0.18266783817375,0.182714070180859,0.182758573985485,0.182800466024926,0.182839238223466,0.182874651189319,0.182906653741064],[0.184148332875018,0.184078736602648,0.183953737869806,0.183792877816299,0.183614558988724,0.18343430028243,0.183266244607869,0.18312167540198,0.183001499350474,0.182904442233336,0.182832463480263,0.182787498258071,0.182766625110591,0.182764308074693,0.182774576075788,0.182792959211317,0.182816191586171,0.182841922224967,0.182868491131049,0.182894756390482,0.182919961187915,0.18294363195757,0.182965500760946,0.182985446462602,0.183003450446008],[0.183647189038725,0.183597016409952,0.183519268904184,0.183427287411293,0.18332970209778,0.183233151290054,0.183143482436837,0.183066075616788,0.183001709861902,0.182949561254474,0.182910774260079,0.182887147230221,0.18287788247035,0.182879748011869,0.182889059511225,0.182903066794496,0.182919770162869,0.18293773902669,0.182955971570229,0.182973786542517,0.182990740147689,0.18300656249838,0.183021109276824,0.183034325183372,0.183046216491509],[0.183377865868223,0.183324390781356,0.183258899505558,0.183194562181333,0.183134062695962,0.183078084245299,0.18302674962012,0.182981923183086,0.182944611426235,0.182914069228936,0.182891139687876,0.182878306136816,0.182876556744458,0.18288351317751,0.182896120074242,0.182912109729622,0.182929849211563,0.182948185049653,0.182966323317534,0.18298373739057,0.183000097293895,0.183015215851094,0.183029007869618,0.18304145941057,0.183052604831653],[0.183222952463478,0.183141800999075,0.18305871506054,0.18299269698286,0.182941707688655,0.182900786643571,0.182864387948419,0.182831710025483,0.182804445585442,0.182781588679109,0.182764065317354,0.182756175718555,0.182761144321495,0.182776362384994,0.182798010896703,0.182823271001594,0.182850132244628,0.182877192523365,0.182903503929556,0.182928454429638,0.182951677467357,0.182972983262325,0.182992306916487,0.183009669498352,0.183025149110068],[0.183113459586417,0.182968294229779,0.182830273042497,0.182732747567972,0.182668094036012,0.182623537338383,0.182585427705436,0.182549969178708,0.182520297251424,0.182494693660005,0.182474584940592,0.18246800925854,0.182481856660487,0.182512111470439,0.182552474105731,0.182598307124639,0.182646318393557,0.182694226428174,0.182740502732555,0.182784174240165,0.182824672552244,0.182861719514202,0.182895240922216,0.182925301931631,0.182952059143167],[0.18300080741674,0.182728424699075,0.182475222268735,0.182303431026697,0.182196580576617,0.182128575387881,0.182071772665086,0.182017763432882,0.181972489576041,0.181932771231035,0.181901159875948,0.181892926365206,0.181921610015394,0.181980030440416,0.182056657039486,0.182143008847056,0.182233074300974,0.18232269593066,0.18240909674964,0.182490517238632,0.182565938421753,0.182634871779676,0.182697200890827,0.182753062968988,0.182802761052035],[0.182837236524187,0.182322986350546,0.18184790353302,0.181529299663141,0.181334970941556,0.181214562409861,0.181114845984537,0.181019287453276,0.180939134883013,0.180868407419919,0.180811858092917,0.180798414194596,0.180853950275087,0.180965091394411,0.181110216389422,0.181273426329655,0.181443456355827,0.181612520453274,0.181775422340412,0.181928874031911,0.182070976064973,0.182200823222752,0.182318207379098,0.182423395244781,0.182516963653326],[0.182558220775986,0.181594438855135,0.180705541513046,0.18011129896547,0.179750801878002,0.179529133330982,0.179346015790228,0.179170132210705,0.179022578155148,0.178892155932027,0.178787741360424,0.178763596760855,0.178868371425695,0.17907708949581,0.179349303863052,0.179655274033313,0.179973930401123,0.1802907124163,0.180595904780252,0.180883362296869,0.181149537264925,0.181392741726147,0.181612591463153,0.18180959016297,0.181984821253844],[0.182062499956034,0.180280186216097,0.178637087473905,0.177539578760893,0.176874746652426,0.176466792932595,0.176130017943373,0.175806344385557,0.175534791523351,0.175294657162328,0.175102339417263,0.175058208996844,0.175252310036161,0.175638499793734,0.176142016472392,0.176707889166951,0.177297175021013,0.177882962966678,0.178447298115173,0.178978824606676,0.179470987730252,0.179920670189832,0.180327164345144,0.180691403555247,0.18101539256001],[0.181188194485131,0.177952297841324,0.174969512520077,0.172977614944953,0.171771469762795,0.171031773060851,0.170421250094247,0.169834378282343,0.169342003053506,0.168906541084745,0.168557756362348,0.168477889562443,0.168830459073405,0.169531711988929,0.170445931786265,0.171473329196074,0.172543211421238,0.173606727471865,0.174631284824895,0.175596270353755,0.176489786539769,0.177306175818044,0.178044154840459,0.178705419103742,0.179293608902935],[0.179691195349551,0.17396165292339,0.168680447671662,0.165153890621941,0.163018700101918,0.16170944655497,0.160628883732405,0.159590132676224,0.15871863545646,0.15794784762683,0.157330466131601,0.157189175557662,0.157813523123584,0.15905522491669,0.160673987276459,0.162493127971455,0.164387481911297,0.16627055627262,0.168084644822213,0.169793251540922,0.171375311874015,0.17282080942757,0.174127472564504,0.175298303813576,0.176339749028968],[0.177254877590563,0.167464765992878,0.158440813799853,0.152415119371925,0.148766909745415,0.146530000948361,0.144683844930521,0.142909101888317,0.141420116451417,0.140103184261954,0.139048347193477,0.138806981476375,0.139873847302473,0.14199557590611,0.144761579859992,0.147869964071098,0.151106860384464,0.154324479631833,0.157424220042909,0.160343721544833,0.163046991654834,0.165516915762661,0.167749612630484,0.169750212914746,0.171529730825415],[0.173623810525342,0.157780875522252,0.143177822762741,0.133426762940449,0.127523110453286,0.123903315535983,0.120915853888697,0.118043942578456,0.115634447090235,0.113503364628371,0.111796405430462,0.111405840214914,0.113132323073673,0.116565840083958,0.121041956402036,0.126072129064242,0.131310265119899,0.136517204247267,0.141533383854938,0.146257889637531,0.150632476753007,0.154629449551071,0.158242527334191,0.161480012931087,0.164359730245322],[0.169121585074213,0.14577327704998,0.124252244928007,0.10988178627472,0.101181400673795,0.0958468220607754,0.0914441333759982,0.0872117291976977,0.0836607979407401,0.0805201681364179,0.0780045778906458,0.0774289994655867,0.0799733875826178,0.0850334908607242,0.0916301083937888,0.0990432573228189,0.106762888383963,0.114436542687229,0.121829067312917,0.128791741377479,0.135238727479872,0.141129209630791,0.146453931803472,0.151225130220431,0.155469072641136],[0.166236222836127,0.13807787580654,0.112123251957349,0.0947923133556846,0.0842995560394994,0.0778660045715762,0.0725563229142898,0.0674520042266058,0.0631695480927463,0.0593819184272314,0.056348091901711,0.0556539414529035,0.0587225076351543,0.0648250562056013,0.0727806591097129,0.081721008379168,0.0910309784904531,0.10028549980833,0.109200975109144,0.117598045243895,0.12537318929866,0.132477182721995,0.138898862655082,0.144652986148355,0.149771232452698]],\"alpha_stroke\":1,\"sizes\":[10,100],\"spans\":[1,20],\"type\":\"surface\",\"contours\":{\"z\":{\"show\":true,\"usecolormap\":true,\"highlightcolor\":\"#ff0000\",\"project\":{\"z\":true}}},\"inherit\":true}},\"layout\":{\"margin\":{\"b\":40,\"l\":60,\"t\":25,\"r\":10},\"title\":\"Meta-Model Response Surface\",\"scene\":{\"xaxis\":{\"title\":\"InitWealth\"},\"yaxis\":{\"title\":\"Redistrib\",\"nticks\":2},\"zaxis\":{\"title\":\"Gini\",\"nticks\":5,\"range\":[0,0.4]}},\"hovermode\":\"closest\",\"showlegend\":false,\"legend\":{\"yanchor\":\"top\",\"y\":0.5}},\"source\":\"A\",\"config\":{\"showSendToCloud\":false},\"data\":[{\"colorbar\":{\"title\":\"\",\"ticklen\":2,\"len\":0.5,\"lenmode\":\"fraction\",\"y\":1,\"yanchor\":\"top\"},\"colorscale\":[[\"0\",\"rgba(68,1,84,1)\"],[\"0.0416666666666667\",\"rgba(70,19,97,1)\"],[\"0.0833333333333333\",\"rgba(72,32,111,1)\"],[\"0.125\",\"rgba(71,45,122,1)\"],[\"0.166666666666667\",\"rgba(68,58,128,1)\"],[\"0.208333333333333\",\"rgba(64,70,135,1)\"],[\"0.25\",\"rgba(60,82,138,1)\"],[\"0.291666666666667\",\"rgba(56,93,140,1)\"],[\"0.333333333333333\",\"rgba(49,104,142,1)\"],[\"0.375\",\"rgba(46,114,142,1)\"],[\"0.416666666666667\",\"rgba(42,123,142,1)\"],[\"0.458333333333333\",\"rgba(38,133,141,1)\"],[\"0.5\",\"rgba(37,144,140,1)\"],[\"0.541666666666667\",\"rgba(33,154,138,1)\"],[\"0.583333333333333\",\"rgba(39,164,133,1)\"],[\"0.625\",\"rgba(47,174,127,1)\"],[\"0.666666666666667\",\"rgba(53,183,121,1)\"],[\"0.708333333333333\",\"rgba(79,191,110,1)\"],[\"0.75\",\"rgba(98,199,98,1)\"],[\"0.791666666666667\",\"rgba(119,207,85,1)\"],[\"0.833333333333333\",\"rgba(147,214,70,1)\"],[\"0.875\",\"rgba(172,220,52,1)\"],[\"0.916666666666667\",\"rgba(199,225,42,1)\"],[\"0.958333333333333\",\"rgba(226,228,40,1)\"],[\"1\",\"rgba(253,231,37,1)\"]],\"showscale\":true,\"x\":[2,6.08333333333333,10.1666666666667,14.25,18.3333333333333,22.4166666666667,26.5,30.5833333333333,34.6666666666667,38.75,42.8333333333333,46.9166666666667,51,55.0833333333333,59.1666666666667,63.25,67.3333333333333,71.4166666666667,75.5,79.5833333333333,83.6666666666667,87.75,91.8333333333333,95.9166666666667,100],\"y\":[0,0.0416666666666667,0.0833333333333333,0.125,0.166666666666667,0.208333333333333,0.25,0.291666666666667,0.333333333333333,0.375,0.416666666666667,0.458333333333333,0.5,0.541666666666667,0.583333333333333,0.625,0.666666666666667,0.708333333333333,0.75,0.791666666666667,0.833333333333333,0.875,0.916666666666667,0.958333333333333,1],\"z\":[[0.388262322816563,0.376316887303776,0.353156156004885,0.322237148486835,0.287358157061879,0.251810521700873,0.218621665708493,0.190108279623754,0.166408685223166,0.147291113409194,0.133128870094527,0.124198465051999,0.119817937453002,0.118932384211412,0.12043135678734,0.123482491774631,0.127476292968063,0.131972781823104,0.136660148394827,0.141322808297304,0.145816816922902,0.150051025376197,0.153972706139481,0.15755664864865,0.160796940303524],[0.35322082066132,0.343315907882724,0.324111510980069,0.298474119741685,0.269553196741471,0.240077850038538,0.212558353535479,0.188915657441117,0.169264455483964,0.153412569519333,0.141669536984761,0.134264634552578,0.13063239536739,0.129898115904394,0.131141035345244,0.133670975283751,0.136982554164927,0.140710950953946,0.144597619353392,0.148463801297473,0.152190140933435,0.155701059513538,0.158952836495678,0.16192456782163,0.164611350901767],[0.298543587694381,0.291822613100984,0.278791503616829,0.261395313148445,0.241771098388973,0.221770684829425,0.203097408559878,0.1870547237089,0.173720455926999,0.162964203012795,0.15499600089945,0.149971426039785,0.147506783912128,0.147008546406744,0.147851932960481,0.149568624298223,0.151815694723895,0.154345595633355,0.15698289095521,0.159606284777927,0.162134788452271,0.164517118201559,0.166723607573487,0.168740072195937,0.170563185460621],[0.254448205755727,0.250294947660128,0.242242367141481,0.231492416137025,0.219365678209397,0.207006477337741,0.195467378672112,0.185553845542703,0.177313971240107,0.170667173529774,0.165743243912093,0.16263832339778,0.16111531199395,0.160807439589077,0.161328622849318,0.162389463772683,0.163778051387687,0.165341413043914,0.166971138061883,0.168592271693594,0.170154767075037,0.171626933473409,0.172990438582497,0.174236517245658,0.175363113857667],[0.224866387107936,0.222435652285015,0.217722914577073,0.211431621223926,0.204334614042592,0.197101578008561,0.190348497194803,0.184546751568884,0.179724489350429,0.175834549870329,0.172952892407269,0.17113578813091,0.170244483978301,0.170064331136236,0.170369376265399,0.170990250700139,0.171802934735833,0.172717902064154,0.17367170606779,0.174620480053491,0.175534934541096,0.176396522877048,0.177194516349013,0.177923785357807,0.178583127021361],[0.206699421748316,0.205326419918855,0.202664658242152,0.199111465331822,0.195103294799955,0.191018333686208,0.187204439798639,0.183927820977541,0.181204379098581,0.179007477199491,0.17738001591694,0.176353787573251,0.175850441836524,0.175748748371055,0.17592108888631,0.176271804212494,0.176730848372023,0.177247657312558,0.177786396814936,0.178322291402965,0.178838798797571,0.179325444245848,0.179776168540173,0.180188074821252,0.18056048400791],[0.196108806133356,0.195352189458813,0.193885844126205,0.191928696945575,0.189721088961507,0.187471255676749,0.185370726702225,0.183566096950459,0.182066134143629,0.180856163078197,0.179959814818238,0.179394624244134,0.179117464237996,0.179061557243617,0.179156600294753,0.179349896490611,0.179602859109174,0.17988763388215,0.180184481065199,0.180479753037441,0.180764337714828,0.181032465490721,0.181280799169471,0.181507743590513,0.181712925274894],[0.190143431750378,0.189733541261098,0.188940093347863,0.187881633442623,0.186688014796013,0.185471704318722,0.184336133804456,0.183360512198925,0.182549598789288,0.181895450547326,0.181410849190638,0.181105324479732,0.180955611280741,0.180925590632483,0.180977223260788,0.181081996667211,0.181219033564063,0.18137326405914,0.181534009005713,0.181693885623151,0.181847965191306,0.181993127465367,0.182127568229552,0.182250425733274,0.182361499131796],[0.186863977921988,0.186643770664875,0.186219358839608,0.185654317097664,0.185017711281491,0.184369279752132,0.18376393707187,0.183243823676203,0.182811515235562,0.182462758690839,0.182204380585234,0.182041561152513,0.181961997916719,0.181946400428009,0.181974425763858,0.182030826896691,0.182104441062471,0.182187211853447,0.182273431312459,0.182359154460872,0.182441748697934,0.182519548452535,0.182591591767636,0.182657420487659,0.182716929667442],[0.185092907885352,0.18497329567433,0.184746419445794,0.184446590980429,0.184109954699714,0.183767614247866,0.183448112528439,0.183173525080991,0.182945288031668,0.182761119195681,0.182624647349051,0.182538805520653,0.182497298087036,0.18248987124871,0.182505658517014,0.182536517623679,0.182576490050312,0.182621277843138,0.18266783817375,0.182714070180859,0.182758573985485,0.182800466024926,0.182839238223466,0.182874651189319,0.182906653741064],[0.184148332875018,0.184078736602648,0.183953737869806,0.183792877816299,0.183614558988724,0.18343430028243,0.183266244607869,0.18312167540198,0.183001499350474,0.182904442233336,0.182832463480263,0.182787498258071,0.182766625110591,0.182764308074693,0.182774576075788,0.182792959211317,0.182816191586171,0.182841922224967,0.182868491131049,0.182894756390482,0.182919961187915,0.18294363195757,0.182965500760946,0.182985446462602,0.183003450446008],[0.183647189038725,0.183597016409952,0.183519268904184,0.183427287411293,0.18332970209778,0.183233151290054,0.183143482436837,0.183066075616788,0.183001709861902,0.182949561254474,0.182910774260079,0.182887147230221,0.18287788247035,0.182879748011869,0.182889059511225,0.182903066794496,0.182919770162869,0.18293773902669,0.182955971570229,0.182973786542517,0.182990740147689,0.18300656249838,0.183021109276824,0.183034325183372,0.183046216491509],[0.183377865868223,0.183324390781356,0.183258899505558,0.183194562181333,0.183134062695962,0.183078084245299,0.18302674962012,0.182981923183086,0.182944611426235,0.182914069228936,0.182891139687876,0.182878306136816,0.182876556744458,0.18288351317751,0.182896120074242,0.182912109729622,0.182929849211563,0.182948185049653,0.182966323317534,0.18298373739057,0.183000097293895,0.183015215851094,0.183029007869618,0.18304145941057,0.183052604831653],[0.183222952463478,0.183141800999075,0.18305871506054,0.18299269698286,0.182941707688655,0.182900786643571,0.182864387948419,0.182831710025483,0.182804445585442,0.182781588679109,0.182764065317354,0.182756175718555,0.182761144321495,0.182776362384994,0.182798010896703,0.182823271001594,0.182850132244628,0.182877192523365,0.182903503929556,0.182928454429638,0.182951677467357,0.182972983262325,0.182992306916487,0.183009669498352,0.183025149110068],[0.183113459586417,0.182968294229779,0.182830273042497,0.182732747567972,0.182668094036012,0.182623537338383,0.182585427705436,0.182549969178708,0.182520297251424,0.182494693660005,0.182474584940592,0.18246800925854,0.182481856660487,0.182512111470439,0.182552474105731,0.182598307124639,0.182646318393557,0.182694226428174,0.182740502732555,0.182784174240165,0.182824672552244,0.182861719514202,0.182895240922216,0.182925301931631,0.182952059143167],[0.18300080741674,0.182728424699075,0.182475222268735,0.182303431026697,0.182196580576617,0.182128575387881,0.182071772665086,0.182017763432882,0.181972489576041,0.181932771231035,0.181901159875948,0.181892926365206,0.181921610015394,0.181980030440416,0.182056657039486,0.182143008847056,0.182233074300974,0.18232269593066,0.18240909674964,0.182490517238632,0.182565938421753,0.182634871779676,0.182697200890827,0.182753062968988,0.182802761052035],[0.182837236524187,0.182322986350546,0.18184790353302,0.181529299663141,0.181334970941556,0.181214562409861,0.181114845984537,0.181019287453276,0.180939134883013,0.180868407419919,0.180811858092917,0.180798414194596,0.180853950275087,0.180965091394411,0.181110216389422,0.181273426329655,0.181443456355827,0.181612520453274,0.181775422340412,0.181928874031911,0.182070976064973,0.182200823222752,0.182318207379098,0.182423395244781,0.182516963653326],[0.182558220775986,0.181594438855135,0.180705541513046,0.18011129896547,0.179750801878002,0.179529133330982,0.179346015790228,0.179170132210705,0.179022578155148,0.178892155932027,0.178787741360424,0.178763596760855,0.178868371425695,0.17907708949581,0.179349303863052,0.179655274033313,0.179973930401123,0.1802907124163,0.180595904780252,0.180883362296869,0.181149537264925,0.181392741726147,0.181612591463153,0.18180959016297,0.181984821253844],[0.182062499956034,0.180280186216097,0.178637087473905,0.177539578760893,0.176874746652426,0.176466792932595,0.176130017943373,0.175806344385557,0.175534791523351,0.175294657162328,0.175102339417263,0.175058208996844,0.175252310036161,0.175638499793734,0.176142016472392,0.176707889166951,0.177297175021013,0.177882962966678,0.178447298115173,0.178978824606676,0.179470987730252,0.179920670189832,0.180327164345144,0.180691403555247,0.18101539256001],[0.181188194485131,0.177952297841324,0.174969512520077,0.172977614944953,0.171771469762795,0.171031773060851,0.170421250094247,0.169834378282343,0.169342003053506,0.168906541084745,0.168557756362348,0.168477889562443,0.168830459073405,0.169531711988929,0.170445931786265,0.171473329196074,0.172543211421238,0.173606727471865,0.174631284824895,0.175596270353755,0.176489786539769,0.177306175818044,0.178044154840459,0.178705419103742,0.179293608902935],[0.179691195349551,0.17396165292339,0.168680447671662,0.165153890621941,0.163018700101918,0.16170944655497,0.160628883732405,0.159590132676224,0.15871863545646,0.15794784762683,0.157330466131601,0.157189175557662,0.157813523123584,0.15905522491669,0.160673987276459,0.162493127971455,0.164387481911297,0.16627055627262,0.168084644822213,0.169793251540922,0.171375311874015,0.17282080942757,0.174127472564504,0.175298303813576,0.176339749028968],[0.177254877590563,0.167464765992878,0.158440813799853,0.152415119371925,0.148766909745415,0.146530000948361,0.144683844930521,0.142909101888317,0.141420116451417,0.140103184261954,0.139048347193477,0.138806981476375,0.139873847302473,0.14199557590611,0.144761579859992,0.147869964071098,0.151106860384464,0.154324479631833,0.157424220042909,0.160343721544833,0.163046991654834,0.165516915762661,0.167749612630484,0.169750212914746,0.171529730825415],[0.173623810525342,0.157780875522252,0.143177822762741,0.133426762940449,0.127523110453286,0.123903315535983,0.120915853888697,0.118043942578456,0.115634447090235,0.113503364628371,0.111796405430462,0.111405840214914,0.113132323073673,0.116565840083958,0.121041956402036,0.126072129064242,0.131310265119899,0.136517204247267,0.141533383854938,0.146257889637531,0.150632476753007,0.154629449551071,0.158242527334191,0.161480012931087,0.164359730245322],[0.169121585074213,0.14577327704998,0.124252244928007,0.10988178627472,0.101181400673795,0.0958468220607754,0.0914441333759982,0.0872117291976977,0.0836607979407401,0.0805201681364179,0.0780045778906458,0.0774289994655867,0.0799733875826178,0.0850334908607242,0.0916301083937888,0.0990432573228189,0.106762888383963,0.114436542687229,0.121829067312917,0.128791741377479,0.135238727479872,0.141129209630791,0.146453931803472,0.151225130220431,0.155469072641136],[0.166236222836127,0.13807787580654,0.112123251957349,0.0947923133556846,0.0842995560394994,0.0778660045715762,0.0725563229142898,0.0674520042266058,0.0631695480927463,0.0593819184272314,0.056348091901711,0.0556539414529035,0.0587225076351543,0.0648250562056013,0.0727806591097129,0.081721008379168,0.0910309784904531,0.10028549980833,0.109200975109144,0.117598045243895,0.12537318929866,0.132477182721995,0.138898862655082,0.144652986148355,0.149771232452698]],\"type\":\"surface\",\"contours\":{\"z\":{\"show\":true,\"usecolormap\":true,\"highlightcolor\":\"#ff0000\",\"project\":{\"z\":true}}},\"frame\":null}],\"highlight\":{\"on\":\"plotly_click\",\"persistent\":false,\"dynamic\":false,\"selectize\":false,\"opacityDim\":0.2,\"selected\":{\"opacity\":1},\"debounce\":0},\"shinyEvents\":[\"plotly_hover\",\"plotly_click\",\"plotly_selected\",\"plotly_relayout\",\"plotly_brushed\",\"plotly_brushing\",\"plotly_clickannotation\",\"plotly_doubleclick\",\"plotly_deselect\",\"plotly_afterplot\",\"plotly_sunburstclick\"],\"base_url\":\"https://plot.ly\"},\"evals\":[],\"jsHooks\":[]}\r\nUm aspecto interessante desse meta modelo mostrado no gráfico é que a riqueza inicial, Initwealth, conforme vai aumentando, vai diminuindo o índice de gini, porém apenas até certo ponto. A partir de um valor em torno de 50, essa variável causa um aumento no índice.\r\nConclusão\r\nEsse modelo busca analisar a distribuição de riqueza em um mundo em que os agentes pagam imposto e recebem assistência do governo, porém a quantidade total de riqueza do sistema é conservada. A intuição aponta para um resultado em que a riqueza se mantém distribuída de forma relativamente igual entre os agentes, porém não é o que ocorre, como aponta a variável Gini, que mede esse índice (de mesmo nome) de concentração de renda. Como foi visto, na configuração padrão do modelo (riqueza inicial de 1 e com todos os agentes com a mesma probabilidade de ser escolhido), Gini rapidamente sai do 0 (situação de igualdade absoluta) e salta para níveis acima de 0.6 — um valor de 1 seria a desigualdade absoluta, com um agente possuindo toda riqueza. A redistribuição de renda em favor dos agentes com menos riqueza atenua um pouco esse resultado, porém Gini continua a atingir valores altos. O aumento da riqueza inicial, por outro lado, possui um efeito drástico sobre o índice, principalmente quando em conjunto com a redistribuição de renda. A análise de sensibilidade corrobora, até certo ponto, esses resultados, mostrando que que o parâmetro InitWealth possui grande impacto sobre a variância de Gini e que há certa influência conjunta com o parâmetro Redistrib — que é apontado como o de maior influência sobre o resultado de Gini. A resposta de superfície do meta modelo também mostra o efeito em conjunto que esses dois parâmetros tem sobre Gini, fazendo esse variar de 0.08 a 0.38.\r\n\r\n\r\n\r\nDRǍGULESCU, A. A.; YAKOVENKO, V. M. Statistical mechanics of money, income, and wealth: a short surveyAIP Conference Proceedings. Anais...American Institute of Physics, 2003\r\n\r\n\r\n\r\n\r\n",
    "preview": "posts/2021-03-27-distriq/distriq_files/figure-html5/unnamed-chunk-19-1.png",
    "last_modified": "2021-04-21T21:40:12-03:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "posts/2021-02-18-compinov/",
    "title": "Modelo - Competição, inovação e retornos crescentes",
    "description": "Este post apresenta uma versão em LSD de um modelo baseado no artigo *Competition, innovation and increasing returns*, de Richardson, G. B. (1996). O modelo mostra que competição pode co-existir com retornos crescentes e altas taxas de inovação.",
    "author": [
      {
        "name": "Rafael Peixoto",
        "url": {}
      }
    ],
    "date": "2021-02-18",
    "categories": [
      "Modelos",
      "LSD"
    ],
    "contents": "\r\n\r\nContents\r\nIntrodução\r\nModelo\r\nEquações\r\nAnálise de Sensibilidade\r\nHHI\r\nHPI\r\n\r\nConclusão\r\n\r\n\r\n\r\nd-article p {\r\n  text-align: justify;\r\n  font-size: 16px;\r\n}\r\n\r\nd-article p code {\r\n  background: rgba(236, 236, 236, 0.8);\r\n}\r\n\r\nd-article div.sourceCode {\r\n  overflow: auto !important;\r\n}\r\n\r\nIntrodução\r\nEsse modelo é inspirado no artigo Competition, innovation and increasing returns, de Richardson (1996), no qual o autor procura analisar o comportamento da competição entre firmas quando há altas taxas de inovação e retornos crescentes. O resultado encontrado pelo autor é que, em livre competição, é provável que exista uma tendência em direção a um “Equilíbrio dinâmico” no qual a taxa de investimento em desenvolvimento de novos produtos cresce ou diminui até o nível em que esse investimento gere retornos normais. Tal resultado vai de encontro um pressuposto muito utilizado por modelos clássicos: em competição perfeita as firmas experenciam retornos decrescentes, uma vez que experenciam custos marginais crescentes.\r\nNo modelo aqui descrito, as firmas competem por mercado colocando à venda seus produtos, que se diferenciam um do outro em qualidade e conveniência. Ao longo do tempo, para cada produto, a qualidade permanece constante e a conveniência aumenta a uma taxa decrecente. Quando a firma adota uma inovação, a qualidade do produto aumenta e a conveniência é restabelecida a um valor mínimo.\r\nModelo\r\nO modelo é composto por um conjunto de N firmas (parâmetro) que oferecem um produto caracterizado, em cada período de tempo, por uma qualidade, Quality, e uma convenciência, Convenience (abreviado aqui para Conv ). Essa conveniência é o inverso do preço do produto, \\(\\small price = 1/Conv\\).\r\nCada consumidor escolhe um produto (uma firma), em cada período de tempo, com probabilidade, Prob, proporcional à combinação linear das duas características (qualidade e conveniência):\r\n\\[\r\n\\small\r\n\\begin{aligned}\r\nProb_{j,t} \\sim (\\alpha) \\times Quality_{i,t} + (1 - \\alpha) \\times Conv_{i,t}\r\n\\end{aligned}\r\n\\]\r\nonde \\(\\alpha\\) (alpha) é um parâmetro entre 0 e 1.\r\nA conveniência cresce (e o preço reduz) ao longo do tempo a uma taxa decrescente, aproximando-se assintoticamente de um nível máximo Cmax:\r\n\\[\r\n\\small\r\n\\begin{aligned}\r\nConv_{i,t} = Conv_{i,t-1} \\times (1 - \\tau \\times ms_{i,t-1})+C_{max} \\times \\tau \\times ms_{i,t-1}\r\n\\end{aligned}\r\n\\]\r\nonde ms é o market share de cada firma e \\(\\tau\\) (tau) é um parâmetro.\r\nQuality permanece constante ao longo do tempo até que uma inovação feita pela firma a aumente. Quando uma firma inova, a Convenience retorna ao seu valor mínimo Cmin.\r\nDessa forma, uma firma adota uma inovação apenas quando essa aumenta a possibilidade de o produto dessa firma ser escolhido por um consumidor, o que depende tanto da qualidade quanto da conveniência. Indicando os valores potenciais após a adoção de uma inovação por ’*’, a firma irá adotar uma inovação apenas quando:\r\n\\[\r\n\\small\r\n\\begin{aligned}\r\n(\\alpha) \\times Quality_{i,t} + (1 - \\alpha) \\times Conv_{i,t} < (\\alpha) \\times Quality^*_{i,t} + (1 - \\alpha) \\times C_{min}\r\n\\end{aligned}\r\n\\]\r\nQuando essa expressão for verdadeira, e a inovação for adotada, o conhecimento acumulado da firma, \\(\\sigma\\) (sigma), e as novas qualidade e conveniência são configuradas para:\r\n\\[\r\n\\begin{aligned}\r\n\\begin{cases}\r\n\\sigma_{i,t} = 0 \\\\\r\nQuality_{i,t} = Quality^*_{i,t}  \\\\\r\nConv_{i,t} = C_{min}\r\n\\end{cases}\\\\\r\n\\end{aligned}\r\n\\]\r\nCaso a inovação não seja adota, a qualidade não se altera e o conhecimento, \\(\\sigma\\), aumenta:\r\n\\[\r\n\\begin{aligned}\r\n\\begin{cases}\r\n\\sigma_{i,t} = \\sigma_{i,t-1}+ \\delta \\\\\r\nQuality_{i,t} = Quality_{i,t-1}  \\\\\r\n\\end{cases}\\\\\r\n\\end{aligned}\r\n\\]\r\nonde \\(\\delta\\) (delta) é um parâmetro constante.\r\nA qualidade potencial (\\(\\small Quality^*\\)) de um novo produto, após a adoção de uma inovação, é calculada a partir de um sorteio aleatório com distribuição normal e com média igual a qualidade existente (dessa firma) e desvio padrão igual ao conhecimento acumulado desde a última inovação bem-sucedida:\r\n\\[\r\n\\small\r\n\\begin{aligned}\r\nQuality^*_{i,t} \\sim \\mathcal{N}(Quality_{i,t-1}, \\  \\sigma_{i,t-1})\r\n\\end{aligned}\r\n\\]\r\nPor fim, o market share (ms) de uma firma é definida como a proporção:\r\n\\[\r\n\\small\r\n\\begin{aligned}\r\nms_{i,t} = \\frac{Prob_{i,t}}{\\sum Prob_{i,t}}\r\n\\end{aligned}\r\n\\]\r\nEstrutura do modelo\r\nO modelo, no LSD, possui a seguinte estrutura (de objetos, ou agentes):\r\n\r\n\r\n\r\nO Mercado é o objeto origem, do qual descende o objeto Firma.\r\nCada um dos dois objetos contêm um conjunto de variáveis (com seus lags indicados em parênteses quando necessário) e parâmetros (cujos valores podem variar para cada cópia do objeto):\r\n\r\n\r\nVariável\r\nParâmetro\r\nMercado\r\nInitHHIHPITotProb\r\nalpha (\\(\\alpha\\))delta (\\(\\delta\\))tau (\\(\\tau\\))CminCmaxC0Q0N\r\nFirma\r\nProbQuality(1)Convenience(1)sigma(1) (\\(\\sigma\\))ms(1)\r\n\r\n\r\nVejamos como é implementada cada Equação para essas variáveis, juntamente com os parâmetros necessários.\r\nEquações\r\nO modelo inteiro é constituido por 9 equações (9 variáveis). Dessas 9, apenas a Equação de Init retorna sempre o valor 1, sendo sua finalidade configurar alguns parâmetros e outras variáveis. A variável ms é a de maior interesse para análise do modelo, uma vez que retorna o market share cada produto (Firma). Para tanto, ela se baseia nos valores de Prob e TotProb (que é apenas a soma das Prob). Prob depende das variáveis Quality e Convenience e do parâmetro alpha. Existem duas equações que calculam índices de mercado, a fim de medir a concorrência: HHI e HPI.\r\nVejamos o modelo completo:\r\n\r\n//#define NO_POINTER_INIT   // uncomment to disable pointer checking\r\n#include \"fun_head_fast.h\"\r\nMODELBEGIN\r\n\r\nEQUATION(\"Init\")\r\n/*\r\nModel initialization\r\n*/\r\nv[0] = V(\"N\");\r\nv[1] = V(\"C0\");\r\nv[2] = V(\"Q0\");\r\nv[3] = COUNT(\"Firm\");\r\nfor (i = v[3] + 1; i <= v[0]; ++i)\r\n    ADDOBJ(\"Firm\");             // add missing objects\r\ni = 1;\r\nCYCLE(cur, \"Firm\")              // set initial conditions (t=0)\r\n{\r\n    WRITELS(cur, \"Convenience\", v[1], 0);\r\n    WRITELS(cur, \"Quality\", v[2], 0);\r\n    WRITELS(cur, \"Prob\", 0, 0);\r\n    WRITELS(cur, \"sigma\", 0, 0);\r\n    WRITELS(cur, \"ms\", 1 / v[0], 0);\r\n}\r\nPARAMETER;\r\nRESULT(1)\r\n\r\nEQUATION(\"Prob\")\r\n/*\r\nProbability of firm being chosen\r\n*/\r\nv[0] = V(\"alpha\");\r\nv[1] = V(\"Quality\");\r\nv[2] = V(\"Convenience\");\r\nv[3] = v[0] * v[1] + (1 - v[0]) * v[2];\r\nRESULT(v[3])\r\n\r\nEQUATION(\"Quality\")\r\n/*\r\nNew product quality, possibly obtained by innovation\r\n*/\r\nv[0] = V(\"alpha\");\r\nv[1] = V(\"Cmin\");\r\nv[2] = VL(\"Quality\", 1);\r\nv[3] = VL(\"Convenience\", 1);\r\nv[4] = VL(\"sigma\", 1);\r\nv[5] = norm(v[2], v[4]);                // innovation potential\r\nv[6] = v[0] * v[2] + (1 - v[0]) * v[3]; // current probability\r\nv[7] = v[0] * v[5] + (1 - v[0]) * v[1]; // innovation probability\r\nif (v[6] < v[7])    // does innovation increase probability?\r\n    v[8] = v[5];    // yes - adopt innovation\r\nelse\r\n    v[8] = v[2];    // no - keep current product quality\r\nRESULT(v[8])\r\n\r\nEQUATION(\"sigma\")\r\n/*\r\nAccumulated knowledge\r\n*/\r\nv[0] = VL(\"Quality\", 1);\r\nv[1] = V(\"Quality\");\r\nif (v[1] == v[0])           // if there was no innovation\r\n{\r\n    v[2] = VL(\"sigma\", 1);\r\n    v[3] = V(\"delta\");\r\n    \r\n    v[4] = v[2] + v[3];     // increase knowledge\r\n}\r\nelse\r\n    v[4] = 0;               // if not, reset knowledge\r\nRESULT(v[4])\r\n\r\nEQUATION(\"Convenience\")\r\n/*\r\nProduct convenience (inverse of price)\r\n*/\r\nv[0] = VL(\"Quality\", 1);\r\nv[1] = V(\"Quality\");\r\nif (v[1] == v[0])           // if there was no innovation\r\n{\r\n    v[2] = V(\"tau\");\r\n    v[3] = V(\"Cmax\");\r\n    v[4] = VL(\"Convenience\", 1);\r\n    v[5] = VL(\"ms\", 1);\r\n    v[6] = v[4] * (1 - v[2] * v[5]) + v[3] * v[2] * v[5];\r\n}\r\nelse\r\n    v[6] = V(\"Cmin\"); \r\nRESULT(v[6])\r\n\r\nEQUATION(\"ms\")\r\n/*\r\nMarket share of a firm\r\n*/\r\nv[0] = V(\"Prob\");\r\nv[1] = V(\"TotProb\");\r\nif (v[1] != 0)              // handle all prob's zero\r\n    v[2] = v[0] / v[1];\r\nelse\r\n    v[2] = 0;\r\nRESULT(v[2])\r\n\r\nEQUATION(\"TotProb\")\r\n/*\r\nSum of probabilities of all firms\r\n*/\r\nRESULT(SUM(\"Prob\"))\r\n\r\nEQUATION(\"HHI\")\r\n/*\r\nHerfindhal-Hirschman Index\r\nSum of the squared firm market shares \r\n*/\r\nv[0] = 0;\r\nCYCLE(cur, \"Firm\")\r\n{\r\n    v[1] = VS(cur, \"ms\");\r\n    v[0] += v[1] * v[1];\r\n}\r\nRESULT(v[0])\r\n\r\nEQUATION(\"HPI\")\r\n/*\r\nHymer & Pashigian Instability Index\r\nSum of the absolute changes in firm market shares\r\n*/\r\nv[0] = 0;\r\nCYCLE(cur, \"Firm\")\r\n{\r\n    v[1] = VLS(cur, \"ms\", 1);\r\n    v[2] = VS(cur, \"ms\");\r\n    v[0] += abs(v[2] - v[1]);\r\n}\r\nRESULT(v[0])\r\n\r\nMODELEND\r\nvoid close_sim( void )\r\n{\r\n}\r\n\r\nVamos analisar cada um dessas equações com mais detalhes. Lembrando que os modelos escritos no LSD são compostos por um conjunto de Equações que são atualizadas em cada período de uma simulação. Essas equações descrevem o comportamento das variáveis (ou funções) que fazem parte do modelo.\r\nA menos que seja dito o contrário, todos os exemplos abaixo (que procuram demonstrar o comportamento de cada variável) utilizam a mesma configuração de simulação:\r\n\r\nParâmetro\r\nValor\r\nalpha (\\(\\alpha\\))\r\n0.5\r\ndelta (\\(\\delta\\))\r\n0.005\r\ntau (\\(\\tau\\))\r\n0.005\r\nCmin\r\n1.0\r\nCmax\r\n10.0\r\nC0\r\n1.0\r\nQ0\r\n0.0\r\nN\r\n5.0\r\n\r\nEQUATION(“Init”)\r\nEssa equação tem como finalidade inicializar o modelo. Mais especificamente, ela cria uma quantidade de cópias do objeto “Firm” igual ao número estabelecido pelo parâmetro N. Para cada uma dessas cópias, inicializa as 5 variáveis possuidas pelo objeto “Firm”, por meio da macro WRITELS(obj, “X”, valor, tempo). Todas as variáveis são ajustadas para o período 0. À Convenience é dado o valor do parâmetro C0; à Quality é dado o valor do parâmetro Q0; à Prob é dado o valor 0; à sigma é dado o valor 0; à ms é dado o valor \\(\\small 1 / N\\). No final, a equação transforma a variável Init em um parâmetro.\r\n\r\nEQUATION(\"Init\")\r\n/*\r\nModel initialization\r\n*/\r\nv[0] = V(\"N\");\r\nv[1] = V(\"C0\");\r\nv[2] = V(\"Q0\");\r\nv[3] = COUNT(\"Firm\");\r\nfor (i = v[3] + 1; i <= v[0]; ++i)\r\n    ADDOBJ(\"Firm\");             // add missing objects\r\ni = 1;\r\nCYCLE(cur, \"Firm\")              // set initial conditions (t=0)\r\n{\r\n    WRITELS(cur, \"Convenience\", v[1], 0);\r\n    WRITELS(cur, \"Quality\", v[2], 0);\r\n    WRITELS(cur, \"Prob\", 0, 0);\r\n    WRITELS(cur, \"sigma\", 0, 0);\r\n    WRITELS(cur, \"ms\", 1 / v[0], 0);\r\n}\r\nPARAMETER;\r\nRESULT(1)\r\n\r\nEQUATION(“Prob”)\r\nEssa equação tem como finalidade calcular a probabilidade de uma firma ser escolhida por um consumidor, ou seja, de a firma vender seu produto. Como ja mencionado, essa probabilidade é uma combinação linear de Quality e Convenience, balanceado pelo parâmetro alpha.\r\n\r\nEQUATION(\"Prob\")\r\n/*\r\nProbability of firm being chosen\r\n*/\r\nv[0] = V(\"alpha\");\r\nv[1] = V(\"Quality\");\r\nv[2] = V(\"Convenience\");\r\nv[3] = v[0] * v[1] + (1 - v[0]) * v[2];\r\nRESULT(v[3])\r\n\r\nVejamos o comportamento dessa variável em uma simulação de 500 períodos. Lembrando que enquanto não há a adoção de uma inovação a variável Quality se mantém constante e Convenience aumenta continuamente; e quando há uma inovação Quality sofre um aumento e Convenience é reduziada a C0. Portanto espera-se que Prob aumente continuamente (devido à Convenience) e as vezes sofra um grande aumento discreto em um período (devido à Quality). Vale ressaltar, aqui, que essa variável não representa exatamente uma probabilidade estatística (com o gráfico aponta, ela não se mantém entre 0 e 1).\r\n\r\n\r\n\r\nEQUATION(“Quality”)\r\nEssa equação tem como finalidade calcular a qualidade do produto de uma firma. Em cada período de tempo, a qualidade pode ser igual à do período anterior, caso não haja adoção de inovação, ou igual à qualidade pós-inovação. Para decidir entre as duas, a firma compara qual irá gerar uma probabilidade maior de venda do produto — if (v[6] < v[7]). Caso a inovação gere um aprobabilidade maior, então ela é adotada e a qualidade do produto muda. A qualidade potencial — quando há inovação — é calculada a partir de um sorteio aleaório — v[5] — com distribuição normal, média igual à qualidade do período anterior e desvio padrão igual ao conhecimento acumulado desde a última inovação (sigma).\r\n\r\nEQUATION(\"Quality\")\r\n/*\r\nNew product quality, possibly obtained by innovation\r\n*/\r\nv[0] = V(\"alpha\");\r\nv[1] = V(\"Cmin\");\r\nv[2] = VL(\"Quality\", 1);\r\nv[3] = VL(\"Convenience\", 1);\r\nv[4] = VL(\"sigma\", 1);\r\nv[5] = norm(v[2], v[4]);                // innovation potential\r\nv[6] = v[0] * v[2] + (1 - v[0]) * v[3]; // current probability\r\nv[7] = v[0] * v[5] + (1 - v[0]) * v[1]; // innovation probability\r\nif (v[6] < v[7])    // does innovation increase probability?\r\n    v[8] = v[5];    // yes - adopt innovation\r\nelse\r\n    v[8] = v[2];    // no - keep current product quality\r\nRESULT(v[8])\r\n\r\nVejamos o comportamento dessa variável em uma simulação de 500 períodos. Espera-se que a qualidade se mova em saltos, quando há inovação, permanecendo constante quando não houver. Em cada período, tem-se, por um lado, o sigma aumentando e, por outro, a Convenience também aumentando.\r\n\r\n\r\n\r\nEQUATION(“sigma”)\r\nEssa equação tem como finalidade calcular o conhecimento acumulado da firma, sigma. Em cada período de tempo em que a qualidade do produto da firma não se altera — ou seja, não há adoção de inovação —, essa variável aumenta em um montante igual a delta, que é um parâmetro constante do modelo. Quando a firma adota uma inovação, sigma é ajustado para 0, ou seja, o conhecimento acumulado é utilizado e então volta-se a um novo processo de acumulação de conhecimento, partindo do zero. Para realizar isso, a equação compara a qualidade do produto no período corrente com a qualidade no período anterior; caso sejam iguais, sigma é incrementado no valor de delta; caso sejam diferentes, sigma é ajustado para zero.\r\n\r\nEQUATION(\"sigma\")\r\n/*\r\nAccumulated knowledge\r\n*/\r\nv[0] = VL(\"Quality\", 1);\r\nv[1] = V(\"Quality\");\r\nif (v[1] == v[0])           // if there was no innovation\r\n{\r\n    v[2] = VL(\"sigma\", 1);\r\n    v[3] = V(\"delta\");\r\n    \r\n    v[4] = v[2] + v[3];     // increase knowledge\r\n}\r\nelse\r\n    v[4] = 0;               // if not, reset knowledge\r\nRESULT(v[4])\r\n\r\nVejamos o comportamento dessa variável em uma simulação de 500 períodos. Espera-se que sigma aumente em delta — que foi estabelecido em 0.005 — cada período, até que haja uma inovação, quando então ela é reajustada para zero. Esse processo se repete inúmeras vezes. Quanto maior o pico que essa variável atinge, maior o tempo decorrido para que a empresa tenha adotado uma inovação.\r\n\r\n\r\n\r\nEQUATION(“Convenience”)\r\nEssa equação tem como finalidade calcular a conveniência da firma. Em cada período de tempo em que não há inovação, essa variável cresce. Quando a firma inova, Convenience retorna ao seu valor mínimo, o parâmetro Cmin — que no caso foi estabelecido para 1. O modo como essa variável cresce, quando não há inovação, é apontado por v[6], levando em consideração os parâmetros tau e Cmax e as variáveis (com lag 1) ms e a própria Convenience.\r\n\r\nEQUATION(\"Convenience\")\r\n/*\r\nProduct convenience (inverse of price)\r\n*/\r\nv[0] = VL(\"Quality\", 1);\r\nv[1] = V(\"Quality\");\r\nif (v[1] == v[0])           // if there was no innovation\r\n{\r\n    v[2] = V(\"tau\");\r\n    v[3] = V(\"Cmax\");\r\n    v[4] = VL(\"Convenience\", 1);\r\n    v[5] = VL(\"ms\", 1);\r\n    v[6] = v[4] * (1 - v[2] * v[5]) + v[3] * v[2] * v[5];\r\n}\r\nelse\r\n    v[6] = V(\"Cmin\"); \r\nRESULT(v[6])\r\n\r\nVejamos o comportamento dessa variável em uma simulação de 500 períodos. Assim como ocorre com sigma, Convenience aumenta em cada período em que não há inovação e retorna a um certo valor quando a inovação ocorre. Porém, tanto esse aumento quanto o valor ao qual a variável retorna são diferentes dos de sigma.\r\n\r\n\r\n\r\nEQUATION(“ms”)\r\nEssa equação tem como finalidade calcular o market share da firma. Em cada período de tempo, cada firma tem o seu ms calculado apenas dividindo-se a sua probabilidade de venda (do seu produto), Prob, pela soma das probabilidades de todas as firmas, TotProb. A equação ainda, por segurança, implementa uma verificação da variável TotProb, para o cado de ela ser igual a zero — o que resultaria em uma divisão por zero.\r\n\r\nEQUATION(\"ms\")\r\n/*\r\nMarket share of a firm\r\n*/\r\nv[0] = V(\"Prob\");\r\nv[1] = V(\"TotProb\");\r\nif (v[1] != 0)              // handle all prob's zero\r\n    v[2] = v[0] / v[1];\r\nelse\r\n    v[2] = 0;\r\nRESULT(v[2])\r\n\r\nVejamos o comportamento dessa variável em uma simulação de 500 períodos. Como visto, a variável Prob, para cada firma, tende a crescer ao longo do tempo. De forma contínua, quando não há inovação (devido ao aumento de Convenience); e com alguns saltos, as veses, quando há inovação (devido ao aumento de Quality).\r\n\r\n\r\n\r\nEQUATION(“TotProb”)\r\nEssa equação tem como finalidade calcular a soma das probabilidades de todas as firmas. A sua equação é simples e evidente: a macro SUM(“X”) soma a variável Prob de cada firma.\r\n\r\nEQUATION(\"TotProb\")\r\n/*\r\nSum of probabilities of all firms\r\n*/\r\nRESULT(SUM(\"Prob\"))\r\n\r\nVejamos o comportamento dessa variável em uma simulação de 500 períodos. espera-se que TotProb, assim como cada instância de Prob, aumente continuamente (devido à Convenience) e as vezes sofra um grande aumento discreto em um período (devido à Quality).\r\n\r\n\r\n\r\nEQUATION(“HHI”)\r\nEssa equação tem como finalidade calcular o Índice Herfindahl–Hirschman, HHI, que é um indicador do grau de concorrência de uma indústria. Esse índice pode variar entre 0 e 1, sendo que quanto mais perto de 0 mais competitivo o mercado e quanto mais perto de 1 mais oligopolista o mercado — o índice será 1 no caso de monopólio. Assim, quanto maior o índice, mais concentrado é o mercado. Ele é definido como a soma dos quadrados dos market shares das firmas que compõem um mercado. Essa equação simplesmente recupera o valor de ms de cada firma e o multiplica por ele mesmo, somando o resultado de cada firma.\r\n\r\nEQUATION(\"HHI\")\r\n/*\r\nHerfindhal-Hirschman Index\r\nSum of the squared firm market shares \r\n*/\r\nv[0] = 0;\r\nCYCLE(cur, \"Firm\")\r\n{\r\n    v[1] = VS(cur, \"ms\");\r\n    v[0] += v[1] * v[1];\r\n}\r\nRESULT(v[0])\r\n\r\nVejamos o comportamento dessa variável em uma simulação de 500 períodos. Como ja visto, os market shares das 5 firmas inicialmente são todos iguais a 20% e vão se distanciando ao longo do tempo. O HHI reflete essa concentração de market share.\r\n\r\n\r\n\r\nEQUATION(“HPI”)\r\nEssa equação tem como finalidade calcular o Índice de Instabilidade Hymer & Pashigian, HPI, que também é um indicador do nível de concorrência de uma indústria — Assim como o HHI. Ele é definido como a soma, de todas as firmas, da mudança de market share de cada uma dessas firmar, em cada período de tempo. Portanto, ele mede a instabilidade de um mercado, no que diz respeito a variações de market share das firmas.\r\n\r\nEQUATION(\"HPI\")\r\n/*\r\nHymer & Pashigian Instability Index\r\nSum of the absolute changes in firm market shares\r\n*/\r\nv[0] = 0;\r\nCYCLE(cur, \"Firm\")\r\n{\r\n    v[1] = VLS(cur, \"ms\", 1);\r\n    v[2] = VS(cur, \"ms\");\r\n    v[0] += abs(v[2] - v[1]);\r\n}\r\nRESULT(v[0])\r\n\r\nVejamos o comportamento dessa variável em uma simulação de 500 períodos. O gráfico dos market shares mostra que em dois momentos (perto dos períodos 50 e 100) houve bruscas mudanças de do ms de algumas firmas. Essas variações grandes são refletidas no gráfico do HPI.\r\n\r\n\r\n\r\nAnálise de Sensibilidade\r\nA análise de sensibilidade (SA) busca avaliar como a incerteza nos resultados das simulações pode ser atribuída a diferentes fontes de incerteza nas equações e configurações do modelo. De forma mais concreta, a SA permite explicar o quanto os resultados produzidos por uma simulação dependem dos seguintes fatores:\r\nEventos estocásticos\r\nParâmetros e valores iniciais das variáveis com lag\r\nForma funcional das equações\r\nO LSD possui um conjunto de ferramentas para a realização de uma análise de sensibilidade, dividido em dois grupos:\r\nFerramentas de amostragem\r\nFerramentas de análise estastítica\r\nO primeiro permite coletar amostras de diferentes resultados do modelo para diferentes configurações dentro do seu espaço paramétrico (todas as possíveis combinações de valores iniciais, para parâmetros e variáveis, e formas funcionais das equações). Tal coleta é referida como Design of Experiments (DoE). Existem diversos métodos de amostragem, como: Full Factorial, Monte Carlo Sampled Factorial, Elementary Effects, and Near-Orthogonal Latin Hypercube.\r\nO segundo permite realizar a análise de sensibilidade através de dois métodos: Morris Elementary Effects (EE) e Sobol Variance Decomposition (SVD). O primeiro emprega uma SA mais simples — one-factor-at-a-time (OAT) — e usualmente é utilizado como um método inicial de triagem e seleção dos fatores mais relevantes que, depois, serão analisados pela SVD SA.\r\nPara o modelo analisado nesse post, será feita uma análise de sensibilidade para duas variáveis: HHI e HPI. Para cada uma será aplicado tanto o método EE quanto o SVD.\r\nHHI\r\nComo visto, HHI, que é um índice de concorrência, se comportou de forma a aumentar nos primeiro períodos da simulação e depois reduzir um pouco no final, refletindo a forma como os market shares evoluíram. Porém, esse foi o comportamento em 1 simulação, ajustada com os parâmetros indicados. Vejamos se alterações nesses parâmetros levariam a resultados diferentes. Como se trata de um índice de concorrência, espera-se que o número de firmas, N, tenha um impacto relevante.\r\nElementary Effects\r\nO termo Elementary Effect é utilizado para se fazer referência tanto ao método de amostragem quanto à análise estatística que dai segue. Esse é o método de amostragem mais simples em análises de sensibilidade, e é utilizado para identificar os fatores menos influentes nos resultados das simulações. O método varia um fator (no caso, parâmetro) de cada vez, a fim de analisar o efeito que essa mudança (e, portanto, o parâmetro) tem sobre o resultado do modelo.\r\nEsse método de SA produz duas medidas de sensibilidade para cada fator:\r\n\\(\\mu\\): importância global do fator para o resultado do modelo\r\n\\(\\sigma\\): efeitos não-lineares e interações\r\nEsse método apliacado para a variável HHI mostra a importância do parâmetro N (como já esperado):\r\n\r\n\r\n\r\n\r\n\r\n\r\nVariance Decomposition\r\nEsse método de SA decompõe a variância do resultado (output) do modelo em frações atribuidas a diferentes fatores (input). Cada fator (sua variância) seria responsável por uma porcentagem da variancia do modelo, e essa influência se daria de forma tanto direta quanto através de interações com outros fatores. Por exemplo, em um modelo com 2 fatores, 60% da variância do resultado do modelo pode ser devido ao primeiro fator, 30% ao segundo fator, e 10% à interação entre esses dois vatores.\r\nComo já previsto, e observado no método EE, espera-se que o parâmetro N apresente uma influência grande no resultado de HHI nesse modelo.\r\n\r\n\r\n\r\n\r\n\r\n\r\nHPI\r\nO HPI, assim como o HHI, é um índice de concorrência, mas que mede a instabilidade dessa concorrência, ao invés do seu grau total de concentração. Assim, espera-se que os parâmetros que mais tenham efeito sobre seus resultados em diferentes simulações sejam aqueles que tenham mais impacto direto sobre variações de market share. Nesse modelo, o que mais impacta os market shares, como visto no gráfico da sua evolução, são as inovações, que geram saltos na Quality dos produtos — a Convenience aumenta de forma linear. Portanto, quanto maior a importância da qualidade para a probabilidade de venda de um produto, maiores são as mudanças bruscas de market share nesse mercado, e isso é determinado pelo parâmetro alpha.\r\nElementary Effects\r\nComo ja era esperado, o método de EE aponta a improtância do parâmetro alpha para os resultados da variável HPI.\r\n\r\n\r\n\r\n\r\n\r\n\r\nVariance Decomposition\r\nPara essa variável, o método de SVD apresenta resultados ligeiramente diferentes dos de EE. Em ambos, o parâmetro alpha aparece como o de maior impacto, porém aqui o parâmetro N se mostra como sendo o segundo de maior impacto.\r\n\r\n\r\n\r\n\r\n\r\n\r\nConclusão\r\nEsse modelo busca analisar um mercado no qual as firmas competem entre si através de diferenciações na qualidade e na conveniência de seus produtos — a probabilidade de venda depende desses dois fatores. O modelo sugere que é possível haver competição mesmo quando há retornos crescentes, caso haja alta taxa de inovação, o que faz com que as qualidades do produtos mudem ao longo do tempo. A análise de sensibilidade mostrou que o número de firmas tem grande impacto sobre a concentração desse mercado e que a proporção entre qualidade de conveniência, dada pelo parâmetro alpha, tem grande impacto sobre a instabilidade da concorrência, uma vez que a inovação gera oscilações consideráveis nos market shares das firmas.\r\n\r\n\r\n\r\nRICHARDSON, G. B. Competition, innovation and increasing returns. Danish Research Unit for Industrial Dynamics (DRUID) Working Paper, n. 96-10, 1996.\r\n\r\n\r\n\r\n\r\n",
    "preview": "posts/2021-02-18-compinov/compinov_files/figure-html5/unnamed-chunk-28-1.png",
    "last_modified": "2021-03-27T22:58:14-03:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "posts/2021-02-10-infoimperf/",
    "title": "Modelo - Informações Imperfeitas para Consumidor",
    "description": "Este post apresenta uma versão em LSD de um modelo que analisa a escolha, por produtos, de consumidores em um mercado com informações imperfeitas.",
    "author": [
      {
        "name": "Rafael Peixoto",
        "url": {}
      }
    ],
    "date": "2021-02-10",
    "categories": [
      "Modelos",
      "LSD"
    ],
    "contents": "\r\n\r\nContents\r\nIntrodução\r\nModelo\r\nEquações\r\nConclusão\r\n\r\n\r\n\r\nd-article p {\r\n  text-align: justify;\r\n  font-size: 16px;\r\n}\r\n\r\nd-article p code {\r\n  background: rgba(236, 236, 236, 0.8);\r\n}\r\n\r\nd-article div.sourceCode {\r\n  overflow: auto !important;\r\n}\r\n\r\nIntrodução\r\nEsse modelo é inspirado no artigo Product Quality in Markets where Consumers are Imperfectly Informed, de Smallwood e Conlisk (1979), no qual os autores procuram analisar a escolha de produtos em um mercado onde os consumidores não possuem informação perfeita a respeito da qualidade dos produtos. Nesse contexto, tais consumidores acabam recorrendo a uma regra de bolso que diz que a popularidade de um produto é um sinal da sua qualidade. Assim, a questão chave que o modelo pretende analisar é se os consumidores, incapazes de avaliar qualidades de forma individual, conseguem fazê-lo de forma coletiva.\r\nO modelo parte de alguns pressupostos bem irrealistas, a fim de prover uma resposta clara:\r\nO preço é idêntico para todos os produtos.\r\nNão há diferenciação na distribuição.\r\nNão há propaganda.\r\nNão há acesso a informações de especialistas.\r\nO modelo, resumidamente, funciona da seguinte maneira: as firmas, com seus produtos, possuem qualidades que diferem uma da outra, porém, de forma “escondida” — os consumidores não possuem acesso a essa informação. Com isso, os consumidores escolhem um produto para comprar e continuam com esse produto até que ele quebre, momento no qual compram um novo. A escolha do produto a ser comprado é aleatória, porém com probabilidades proporcionais aos market shares das firmas.\r\nModelo\r\nA linha de eventos do modelo se inicia com os consumidores decidindo se vão ou não ao mercado comprar um novo produto. Tal decisão depende unicamente do estado do seu produto atual, se ele está quebrado ou funcionando:\r\n\\[\r\n\\begin{aligned}\r\n& produto =  \r\n\\begin{cases}\r\nproduto \\ atual & , \\ se \\ funcionando \\\\\r\nproduto \\ novo & , \\ se \\ quebrado \\\\\r\n\\end{cases}\\\\\r\n\\end{aligned}\r\n\\]\r\nTodo produto, quando usado (ou seja, em cada período de tempo), possui uma probabilidade de quebrar (Breaking Down):\r\n\\[\r\n\\begin{aligned}\r\n& quebrado =  \r\n\\begin{cases}\r\nsim & , \\ probabilidade = BD \\\\\r\nnão & , \\ probabilidade = 1 - BD \\\\\r\n\\end{cases}\\\\\r\n\\end{aligned}\r\n\\]\r\nQuando o produto quebra, o consumidor precisa comprar um novo. Porém, ele não conhece a probabilidade de quebrar, BD, de cada produto, para usar como parâmetro de escolha. Por outro lado, ele pode observar os produtos dos outros consumidores. Assim, ele pode escolher qual produto comprar com base em probabilidades proporcionais aos market shares dos produtos (ou seja, quais proporções dos consumidores utilizam quais produtos):\r\n\\[\r\n\\begin{aligned}\r\np_i = \\frac{ms_i^\\alpha}{\\sum_{j=1}^n ms_j^\\alpha}\r\n\\end{aligned}\r\n\\]\r\nEssa equação apenas calcula a probabilidade de escolher um dado produto, baseado na proporção do market share desse produto. O parâmetro \\(\\alpha\\) indica o peso dado ao market share na formação das probabilidades. Por exemplo:\r\n\\(\\alpha = 0\\): todo \\(p_i = 1\\), independente do market share.\r\n\\(\\alpha \\uparrow\\): mais importante o market share na formação das probabilidades.\r\n\\(\\alpha \\approx \\infty\\): A firma com maior market share possui \\(p_i \\approx 1\\), e todas as outras \\(p_j \\approx 0\\).\r\nCom isso, \\(\\alpha\\) pode ser entendido como a confiança que os consumidores têm no market share para selecionar o melhor produto, ou seja, no pressuposto de que o produto mais vendido é o de melhor qualidade.\r\nEstrutura do modelo\r\nO modelo, no LSD, possui a seguinte estrutura (de objetos, ou agentes):\r\n\r\n\r\n\r\nO Mercado é o objeto origem, do qual descendem os objetos Oferta e Demanda. Por sua vez, Oferta possui o objeto Firma como descentende, e Demanda possui Consumidor como descendente.\r\nCada um desses objetos contêm um conjunto de variáveis (com seus lag indicados quando necessário) e parâmetros (cujos valores podem variar para cada cópia do objeto):\r\n\r\n\r\nVariável\r\nParâmetro\r\nMercado\r\nInit\r\nTotalUsers\r\nOferta\r\nInitTrade\r\nalpha\r\nFirma\r\nNumUsers(1)ms_users(1)Visibility\r\nIdFirmBDSalesNumLost\r\nDemanda\r\nEndTrade\r\n-\r\nConsumidor\r\nProdUsed(1)\r\n-\r\n\r\nAlém disso, alguns dos objetos desse modelo contêm também funções, que são semelhantes às variáveis, mas que podem ser computadas diversas vezes dentro de um mesmo período de tempo da simulação. Assim como as variáveis, precisam ser invocadas com um bloco de Equação específico. As funções (e os objetos que as contêm) presentes nesse modelo são:\r\nOferta: Purchase.\r\nConsumidor: IsBroken.\r\nVejamos como é implementada cada Equação para essas variáveis e funções, juntamente com os parâmetros necessários.\r\nEquações\r\nO modelo inteiro é constituido por 9 equações (7 variáveis e 2 funções). Porém, dessas 9, 3 Equações (Init, InitTrade, EndTrade) retornam sempre o valor 1, sendo sua finalidade apenas configurar alguns parâmetros e outras variáveis. A variável NumUsers é a de maior interesse para análise do modelo, uma vez que retorna o número de consumidores de cada produto (Firma). A variável ms_users calcula a proporção de consumidores, baseada no número total. A variável Visibility utiliza o \\(\\alpha\\) — que indica o quão importante é o market share — para gerar as probabilidade de cada produto ser comprado. As funções Purchase e IsBroken são necessárias para calcular a variável ProdUsed, que determina qual produto cada consumidor vai usar.\r\n\r\n//#define EIGENLIB          // uncomment to use Eigen linear algebra library\r\n//#define NO_POINTER_INIT   // uncomment to disable pointer checking\r\n#include \"fun_head_fast.h\"\r\n// do not add Equations in this area\r\nMODELBEGIN\r\n// insert your equations here, between the MODELBEGIN and MODELEND words\r\n\r\nEQUATION(\"ProdUsed\")\r\n/*\r\nDetermine the product used by the consumer at each time step\r\n*/\r\nv[0] = V(\"IsBroken\"); //breaks ?\r\nif(v[0] == 1)\r\n    v[1] = V(\"Purchase\"); //yes, buy a new produc\r\nelse\r\n    v[1] = VL(\"ProdUsed\", 1); //no, keep on using the previous one\r\nRESULT(v[1])\r\n\r\nEQUATION(\"IsBroken\")\r\n/*\r\nCheck whether the product breaks down or not.\r\nReturn 1 if the product breaks or 0 if not.\r\n*/\r\nv[0] = VL(\"ProdUsed\", 1); //product owned by the consumer at t-1\r\ncur = SEARCH_CND(\"IdFirm\", v[0]); //search the object with IdFirm\r\nv[2] = VS(cur, \"BD\"); //read the value of the prob. to break down\r\nif(RND < v[2]) //\r\n    {\r\n    v[1] = 1; //product broken\r\n    V(\"InitTrade\"); //just to ensure NumLost is reset\r\n    INCRS(cur, \"NumLost\", 1);\r\n    }\r\nelse\r\n    v[1] = 0; //product not broken\r\nRESULT(v[1])\r\n\r\nEQUATION(\"Purchase\")\r\n/*\r\nMake a purchase for the calling object (supposedly a consumer).\r\n*/\r\ncur1 = RNDDRAW(\"Firm\", \"Visibility\"); //choose randomly one of the products\r\nv[0] = VS(cur1, \"IdFirm\"); //return the ID of the chosen firm\r\nV(\"InitTrade\"); //ensure that firms are ready to sell\r\nINCRS(cur1, \"Sales\", 1); //increase the Sales of the chosen firm\r\nRESULT(v[0])\r\n\r\nEQUATION(\"NumUsers\")\r\n/*\r\nNumber of users, computed, after the end of the trading period, \r\nby summing to the previous users the new sales and removing the lost users\r\n*/\r\nV(\"EndTrade\"); //ensure that buyers finished the shopping\r\nv[0] = VL(\"NumUsers\", 1); //former number of users\r\nv[1] = V(\"Sales\"); //sales at this time\r\nv[2] = V(\"NumLost\"); //lost users at this time\r\nv[4]= v[0] + v[1] - v[2];\r\nRESULT(v[4])\r\n\r\nEQUATION(\"ms_user\")\r\n/*\r\nMarket shares of users, computed as the ratio of users over the total number of users\r\n*/\r\nv[0] = V(\"TotalUsers\");\r\nv[1] = V(\"NumUsers\");\r\nRESULT(v[1] / v[0])\r\n\r\nEQUATION(\"Visibility\")\r\n/*\r\nVisibility, implemented to avoid the math error of a power of 0.\r\n*/\r\nv[0] = V(\"alpha\");\r\nv[1] = VL(\"ms_user\", 1);\r\nif(v[1] == 0)\r\n    v[2] = 0;\r\nelse\r\n    v[2] = pow(v[1], v[0]);\r\nRESULT(v[2])\r\n\r\nEQUATION(\"InitTrade\")\r\n/*\r\nInitialize the trading period. For each firm set to 0 the parameter Sales and NumLost\r\n*/\r\nCYCLE(cur, \"Firm\")\r\n    { //for all firms set to 0 Sales and NumLost\r\n    WRITES(cur, \"Sales\", 0);\r\n    WRITES(cur, \"NumLost\", 0);\r\n    }\r\nRESULT(1)\r\n\r\nEQUATION(\"EndTrade\")\r\n/*\r\nFor each consumer ensures that the variable ProdUsed is updated so that Sales and NumLost are filled with the correct values\r\n*/\r\nCYCLE(cur, \"Consumer\")\r\n    VS(cur, \"ProdUsed\");\r\nRESULT(1)\r\n\r\nEQUATION(\"Init\")\r\n/*\r\nInitialize demand. It assumes that initially there is only 1 consumer. ms_users[0] are the prob of first purchase\r\n*/\r\ncur = SEARCH(\"Demand\");//search the object Demand\r\nv[0] = V(\"TotalUsers\");//number of consumers\r\nADDNOBJS(cur, \"Consumer\", v[0] - 1);//create new objects\r\nCYCLES(cur,cur1, \"Consumer\")\r\n    {\r\n    v[1] = V(\"Purchase\");\r\n    WRITELS(cur1, \"ProdUsed\", v[1], t - 1);//replace the existing value\r\n    }\r\nPARAMETER //transform the variable into a param\r\nRESULT(1)\r\n\r\nMODELEND\r\n// do not add Equations in this area\r\nvoid close_sim( void )\r\n{\r\n    // close simulation special commands go here\r\n}\r\n\r\nVamos analisar cada um dessas equações com mais detalhes. Lembrando que os modelos escritos no LSD são compostos por um conjunto de Equações que são atualizadas em cada período de uma simulação. Essas equações descrevem o comportamento das variáveis (ou funções) que fazem parte do modelo.\r\nEQUATION(“ProdUsed”)\r\nEssa equação tem como finalidade indicar, em cada período de tempo, qual o produto (Firma) usado por cada um dos consumidores. Para tanto, ela verifica se o produto atual do consumidor em questão está quebrado ou não (por meio da variável IsBroken). Caso esteja quebrado, é o utilizado a função Purchase para comprar um novo produto; caso não esteja quebrado, é utilizado o mesmo produto que no período anterior, por meio da própria variável prodUsed, com um lag de 1 período. A equação retorna o ID da firma, informado pelo parâmetro IdFirm.\r\n\r\nEQUATION(\"ProdUsed\")\r\n/*\r\nDetermine the product used by the consumer at each time step\r\n*/\r\nv[0] = V(\"IsBroken\"); //breaks ?\r\nif(v[0] == 1)\r\n    v[1] = V(\"Purchase\"); //yes, buy a new produc\r\nelse\r\n    v[1] = VL(\"ProdUsed\", 1); //no, keep on using the previous one\r\nRESULT(v[1])\r\n\r\nPor exemplo, seja uma simulação com 500 períodos, \\(\\alpha = 0.5\\), 10 Firmas e 10000 consumidores. Vejamos o comportamento da variável ProdUsed para 2 consumidores:\r\n\r\n\r\n\r\nEQUATION(“IsBroken”)\r\nEssa equação, que é de uma função (não uma variável), tem como finalidade indicar se o produto usado por um consumidor irá quebrar no período corrente. Para tanto, primeiramente, ela verifica qual foi o produto usado no período anterior, assim como o ID da sua Firma produtora. Com isso, a equação verifica a probabilidade que esse produto tem de quebrar (com base no parâmetro BD referente à Firma produtora). Então é feito um sorteio aleatório, com distribuição uniforme entre 0 e 1 (Macro RND): caso o valor seja menor que o parâmetro BD, o produto está quebrado nesse período; caso seja maior, o produto não está quebrado. A equação retorna 0 (produto não quebrado) ou 1 (produto quebrado). Além disso, quando o produto está quebrado, a equação faz um acréscimo unitário no parâmetro NumLost da Firma em questão — através da Macro INCRS(obj, “x”, value) que, no caso, fica INCRS(cur, “NumLost”, 1).\r\n\r\nEQUATION(\"IsBroken\")\r\n/*\r\nCheck whether the product breaks down or not.\r\nReturn 1 if the product breaks or 0 if not.\r\n*/\r\nv[0] = VL(\"ProdUsed\", 1); //product owned by the consumer at t-1\r\ncur = SEARCH_CND(\"IdFirm\", v[0]); //search the object with IdFirm\r\nv[2] = VS(cur, \"BD\"); //read the value of the prob. to break down\r\nif(RND < v[2]) //\r\n    {\r\n    v[1] = 1; //product broken\r\n    V(\"InitTrade\"); //just to ensure NumLost is reset\r\n    INCRS(cur, \"NumLost\", 1);\r\n    }\r\nelse\r\n    v[1] = 0; //product not broken\r\nRESULT(v[1])\r\n\r\nPor exemplo, seja uma simulação com 500 períodos, \\(\\alpha = 0.5\\), 10 Firmas e 10000 consumidores. Vejamos o comportamento da função IsBroken para 1 consumidor. Lembrando que a probabilidade de quebrar depende do parâmetro BD, que nesse exemplo foi definido com o valor de 10% para a Firma 1, 11% para a Firma 2, …, 19% para a Firma 10. Em cada período de tempo, o produto possuído pelo consumidor irá determinar a probabilidade de quebrar.\r\n\r\n\r\n\r\nEQUATION(“Purchase”)\r\nAssim como a EQUATION(“IsBroken”), essa equação também é de uma função. Funções podem ser chamadas diversas vezes em um mesmo período de tempo, porém apenas a última vez é salva. No caso de IsBroken, isso não foi muito importante, pois cada consumidor a chamava apenas uma vez por período, sendo salvos todos seus valores para cada consumidor. No caso de Purchase, essa restrição é importante, pois os valores pertencem ao objeto Oferta, que possui apenas 1 cópia. Assim, é possível que diversos consumidores chamem a função Purchase, porém apenas o valor do último que o fizer será salvo.\r\nA equação funciona da seguinte maneira: primeiramente, sorteada-se uma firma, com probabilidades iguais às suas Visbility (que dependem do market share); depois, guarda-se o ID dessa firma; por fim, faz-se um incremento unitário no parâmetro Sales dessa firma. A equação retorna o ID da firma sorteada.\r\n\r\nEQUATION(\"Purchase\")\r\n/*\r\nMake a purchase for the calling object (supposedly a consumer).\r\n*/\r\ncur1 = RNDDRAW(\"Firm\", \"Visibility\"); //choose randomly one of the products\r\nv[0] = VS(cur1, \"IdFirm\"); //return the ID of the chosen firm\r\nV(\"InitTrade\"); //ensure that firms are ready to sell\r\nINCRS(cur1, \"Sales\", 1); //increase the Sales of the chosen firm\r\nRESULT(v[0])\r\n\r\nPor exemplo, seja uma simulação com 500 períodos, \\(\\alpha = 0.5\\), 10 Firmas e 10000 consumidores. Vejamos o comportamento da função Purchase (para o último consumidor que a chamar, em cada período).\r\n\r\n\r\n\r\nEQUATION(“NumUsers”)\r\nEssa equação tem como finalidade indicar o número de usuários de cada produto (firma) ao fim de cada período, após computar as adições (vendas para novos usuários) e subtrações (perdas de usuários devido à quebra de produtos) de consumidores. Para tanto, ela simplesmente verifica o número de usuários (de cada firma) no período anterior, o número de vendas no período corrente e o número de usuários perdidos também no período corrente, e computa o novo número de usuários.\r\n\r\nEQUATION(\"NumUsers\")\r\n/*\r\nNumber of users, computed, after the end of the trading period, \r\nby summing to the previous users the new sales and removing the lost users\r\n*/\r\nV(\"EndTrade\"); //ensure that buyers finished the shopping\r\nv[0] = VL(\"NumUsers\", 1); //former number of users\r\nv[1] = V(\"Sales\"); //sales at this time\r\nv[2] = V(\"NumLost\"); //lost users at this time\r\nv[4]= v[0] + v[1] - v[2];\r\nRESULT(v[4])\r\n\r\nPor exemplo, seja uma simulação com 500 períodos, \\(\\alpha = 0.5\\), 10 Firmas e 10000 consumidores. Vejamos o comportamento da variável NumUsers para cada firma. Lembrando que a probabilidade de quebrar depende do parâmetro BD, que nesse exemplo foi definido com o valor de 10% para a Firma 1, 11% para a Firma 2, …, 19% para a Firma 10.\r\n\r\n\r\n\r\nComo o gráfico mostra, quanto maior o parâmetro BD (probabilidade de o produto quebrar) da firma, menor é número de usuários que ela consegue manter no longo prazo. Essa divergência é rapidamente atingida no começo e depois mantida ao longo do tempo. Como existem 10000 consumidores e 10 Firmas, inicialmente cada firma fica com um número de consumidores em torno de 1000. Um exame dos primeiros períodos mostra essa rapidez:\r\n\r\n\r\n\r\nEQUATION(“ms_user”)\r\nEssa equação apenas divide o número de usuários de cada Firma, NumUsers, pelo total de usuários, parâmetro TotalUsers.\r\n\r\nEQUATION(\"ms_user\")\r\n/*\r\nMarket shares of users, computed as the ratio of users over the total number of users\r\n*/\r\nv[0] = V(\"TotalUsers\");\r\nv[1] = V(\"NumUsers\");\r\nRESULT(v[1] / v[0])\r\n\r\nO gráfico dessa variável é igual ao de NumUsers, porém com uma escala diferente, refletindo a porcentagem e não o número total de usuários de cada Firma.\r\n\r\n\r\n\r\nEQUATION(“Visibility”)\r\nEssa equação tem como finalidade indicar a visibilidade de cada produto (firma) ao fim de cada período, após computar as adições (vendas para novos usuários) e subtrações (perdas de usuários devido à quebra de produtos) de consumidores. O mark share — que depende das vendas e perdas — é a base da visibilidade. Mais especificamente, essa é calculada elevando-se o market share (no período anterior) ao expoente alpha. Uma Exceção que a equação implemente é que caso o market share seja igual a zero, a visibilidade também será zero. Isso é feito para eliminar a possibilidade de uma Firma possuir market share zero mas visibilidade igual a um — caso o alpha seja igual a zero.\r\n\r\nEQUATION(\"Visibility\")\r\n/*\r\nVisibility, implemented to avoid the math error of a power of 0.\r\n*/\r\nv[0] = V(\"alpha\");\r\nv[1] = VL(\"ms_user\", 1);\r\nif(v[1] == 0)\r\n    v[2] = 0;\r\nelse\r\n    v[2] = pow(v[1], v[0]);\r\nRESULT(v[2])\r\n\r\nPor exemplo, seja uma simulação com 500 períodos, \\(\\alpha = 0.5\\), 10 Firmas e 10000 consumidores. Vejamos o comportamento da variável Visibility para cada firma. Como dito, em cada período, o valor dessa variável é igual ao market share elevado à potencia alpha, que no caso é igual 0.5. Ou seja, o valor de Visibility, em cada período, é simplesmente a raiz quadrada do market share. Portanto, o gráfico terá o mesmo comportamento, porém mais “esticado” — uma vez que os valores estão entre 0 e 1.\r\n\r\n\r\n\r\nDessa forma, a Visibility deriva diretamente do market share, que deriva do NumUsers, que depende, em cada período, do número de Sales e de NumLost, que são dois parâmetros das Firmas.Sales é determinado pela equação (função) de Purchase: cada consumidor que teve um produto quebrado chama essa função, e a firma escolhida para realizar a venda é determinada por um sorteio aleatório com probabilidades iguais a Visibility.NumLost é determinado pela equação (função) de IsBroken: todo consumidor chama essa função em todos os períodos, e caso o produto esteja quebrado (possui probabilidade BD de quebrar, que varia de produto para produto) a Firma produtora desse produto perde um consumidor.\r\nAssim:\r\nNumLost é maior para Firmas com BD maior, o que leva a um menor market share.\r\nSales é maior para Firmas com maior Visibility, o que leva a um maior market share.\r\nPara entender melhor essa dinâmica, vamos supor que \\(\\alpha = 0\\) e, portanto, todas as firmas possuem Visiblity constante e igual a 1. Nesse caso, Sales será semelhante para todas as Firmas — todas terão a mesma probabilidade de serem sorteadas. Assim, o NumUsers, e o market share, irá depender predominantemente do NumLost. Como esse depende do parâmetro BD, que cresce de 10% a 19% entre as 10 Firmas, a Firma com maior BD terá o maior NumLost e, poranto, o menor market share. Porém, isso ocorre de forma cada vez menor, já que tanto menor o NumUsers menor o NumLost. Isso explica a curva acentuada nos primeiros períodos e depois uma variação em torno de uma média no longo prazo.\r\nVejamos um exemplo: a Firma 1 possui \\(BD = 0.1\\) e a Firma 2 \\(BD=0.19\\); digamos que no primeiro período cada Firma possua mil consumidores. Assim, em média, a Firma 1 perde 100 consumidores por período e a Firma 2 per 190; após 100 períodos, a Firma 1 possui 2000 consumidores e a Firma 2 possui 500; nessa altura, em cada período, a Firma 1 perde 200 consumidores e a Firma 2 perde 95. Portanto, por mais que a Firma 1 perca menos usuários proporcionalmente, em números totais ela perde mais por possuir mais consumidores. Se todo o modelo se resumisse apenas a isso, seria de se esperar os que números de consumidores dessas duas firmas se estabilizasse em torno de 1600 para a Firma 1 e 800 para a Firma 2, pois dessa forma elas perderiam, em média, o mesmo número de consumidores por período.\r\nPara o caso em que \\(\\alpha \\ne 0\\), como os exemplos mostrados ao longo do texto (\\(\\alpha=0.5\\)) vale a mesma dinâmica, porém, como as Visibility irão divergir, haverá divergência no Sales e, por fim, no market share. Isso irá acentuar a diferença entre números de consumidores para cada Firma no longo prazo, porém a dinâmica permanece a mesma: uma grande diferenciação nos primeiros períodos, depois uma estabilidade causada pelo NumLost.\r\nAs últimas 3 equações (InitTrade, EndTrade, Init) retornam sempre 1 e servem para configurar o modelo.\r\nEQUATION(“InitTrade”)\r\nEssa equação tem como finalidade configurar o período de negocioação. Os parâmetros Sales e NumLost computam os ganhos e perdas de consumidores em cada período, portanto precisam ser zeradas ao início de cada período. Essa equação faz apenas isso. Ela ajusta para 0 o valor desses parâmetros para cada uma das firmas.\r\n\r\nEQUATION(\"InitTrade\")\r\n/*\r\nInitialize the trading period. For each firm set to 0 the parameter Sales and NumLost\r\n*/\r\nCYCLE(cur, \"Firm\")\r\n    { //for all firms set to 0 Sales and NumLost\r\n    WRITES(cur, \"Sales\", 0);\r\n    WRITES(cur, \"NumLost\", 0);\r\n    }\r\nRESULT(1)\r\n\r\nEQUATION(“EndTrade”)\r\nEssa equação apenas faz uma leitura do produto usado, ProdUsed, por cada consumidor, ao fim de cada período, para assegurar que Sales e NumLost sejam preenchidos com os valores corretos.\r\n\r\nEQUATION(\"EndTrade\")\r\n/*\r\nFor each consumer ensures that the variable ProdUsed is updated so that Sales and NumLost are filled with the correct values\r\n*/\r\nCYCLE(cur, \"Consumer\")\r\n    VS(cur, \"ProdUsed\");\r\nRESULT(1)\r\n\r\nEQUATION(“Init”)\r\nEssa equação inicializa a demanda. Primeiramente, ela associa o objeto “Demanda” a um ponteiro cur e guarda o valor do parâmetro TotalUsers — que é ajustado pelo modelador no início da simulação. A equação então cria um número de objetos, chamados “Consumidores”, igual a TotalUsers menos 1 (ela assume que o modelo começa com 1 consumidor), e aloca esse objetos como descendentes do objeto “Demanda”, que ela guardou no ponteiro cur. Após isso, equação então faz um ciclo para chamar a função Purchase para cada um dos consumidores recém criados, e utiliza o valor retornado por Purchase para substituir o valor de ProdUsed no período \\(t-1\\), que foi inicialmente configurado pelo modelador para ser 0 (para esse primeiro e único consumidor existente antes dessa equação ser chamada). Após tudo isso, essa variável Init é transformada em um parâmetro.\r\n\r\nEQUATION(\"Init\")\r\n/*\r\nInitialize demand. It assumes that initially there is only 1 consumer. ms_users[0] are the prob of first purchase\r\n*/\r\ncur = SEARCH(\"Demand\");//search the object Demand\r\nv[0] = V(\"TotalUsers\");//number of consumers\r\nADDNOBJS(cur, \"Consumer\", v[0] - 1);//create new objects\r\nCYCLES(cur,cur1, \"Consumer\")\r\n    {\r\n    v[1] = V(\"Purchase\");\r\n    WRITELS(cur1, \"ProdUsed\", v[1], t - 1);//replace the existing value\r\n    }\r\nPARAMETER //transform the variable into a param\r\nRESULT(1)\r\n\r\nConclusão\r\nEsse modelo explora a competição entre firmas, por consumidores em um mercado no qual não há informação perfeita e esses consumidores precisam tomar suas decisões com base numa regra de bolso, que no caso é assumir que a firma com maior market share possui o melhor produto. Porém, o modelo assume que o market share depende da qualidade do produto, uma vez que a probabilidade desse quebrar influencia diretamente no número de consumidores da firma. A visibilidade da firma acentua as diferenças de market share entre essas, porém o que determina a dinâmica do modelo de forma mais preponderante é o fato de que as probabilidades BD definem o número de consumidores perdidos e portanto, estabelecem o formato das trajetórias dos market shares.\r\n\r\n\r\n\r\nSMALLWOOD, D. E.; CONLISK, J. Product quality in markets where consumers are imperfectly informed. The Quarterly Journal of Economics, v. 93, n. 1, p. 1–23, 1979.\r\n\r\n\r\n\r\n\r\n",
    "preview": "posts/2021-02-10-infoimperf/infoimperf_files/figure-html5/unnamed-chunk-2-1.png",
    "last_modified": "2021-03-27T22:58:50-03:00",
    "input_file": {},
    "preview_width": 802,
    "preview_height": 729
  },
  {
    "path": "posts/2021-02-09-externrede/",
    "title": "Modelo - Externalidades de Rede",
    "description": "Este post apresenta uma versão em LSD do modelo de externalidades de rede proposto por Brian Arthur.",
    "author": [
      {
        "name": "Rafael Peixoto",
        "url": {}
      }
    ],
    "date": "2021-02-09",
    "categories": [
      "Modelos",
      "LSD"
    ],
    "contents": "\r\n\r\nContents\r\nIntrodução\r\nModelo\r\nEquações\r\nConclusão\r\n\r\n\r\n\r\nd-article p {\r\n  text-align: justify;\r\n  font-size: 16px;\r\n}\r\n\r\nd-article p code {\r\n  background: rgba(236, 236, 236, 0.8);\r\n}\r\n\r\nd-article div.sourceCode {\r\n  overflow: auto !important;\r\n}\r\n\r\nIntrodução\r\nO modelo de externalidades de rede proposto por Brian Arthur explora a dinâmica de alocação sob retornos crescentes, em um contexto no qual agentes escolhem entre tecnologias que competem entre si para serem adotadas. Quando duas ou mais tecnologias, com retornos crescentes, competem por um mercado de consumidores em potencial, eventos aleatórios podem, por mero acaso, dar uma vantagem inicial para uma delas. Com isso, essa tecnologia passa a ser mais adotada, o que pode fazer com que ela seja mais aperfeiçoada e, como consequência, adotada por mais consumidores ainda. Dessa forma, uma tecnologia que, por acaso, ganhe uma liderança inicial em adoções, pode dominar o mercado, bloqueando — locking out — o crescimento das demais.\r\nIsso ocorre, de acordo com Brian Arthur, pois os consumidores valorizam um produto (ou tecnologia) por dois motivos:\r\nSuas próprias preferências pessoais (como pressuposto na teoria econômica clássica)\r\nExternalidades de rede, ou seja, a qualidade adicionada a um produto devido ao fato de outros agentes o usarem.\r\nA partir disso, o modelo proposto por Arthur busca examinar explicitamente os efeitos, sobre a dinâmica da adoção de uma tecnologia (ou escolha de um produto), das externalidades de rede.\r\nModelo\r\nO modelo aqui discutido considera dois grupos de consumidores, tipo 0 e tipo 1, e dois tipos de produtos, MS e Apple. Um consumidor avalia um produto atribuindo a ele uma utilidade composta por dois elementos:\r\nA própria preferência do consumidor\r\nO valor de rede do produto\r\nAs preferências dos consumidores são fixas, embora divergindo para cada um dos grupos de consumidores e tipos de produto. O valor de rede, por sua vez, muda com o número de outros usuários usando o tipo de produto em questão.\r\nA partir dessas definições, vamos expressar formalmente a utilidade dos consumidores. Sejam \\(v^{MS}_0\\) e \\(v^{Apple}_0\\) as preferências próprias do consumidor tipo 0 para os produtos MS e Apple. Adicionalmente, sejam \\(N^{MS}\\) e \\(N^{Apple}\\) os números de outros consumidores que utilizam cada um desses produtos respectivamente. Por fim, seja \\(x_0\\) o efeito da externalidade de rede para o consumidor do tipo 0. O mesmo é feito para o consumidor tipo 1:\r\nTipo 0\r\n\\(U^{MS}_0 = v^{MS}_0 + x_0 \\times N^{MS}\\), escolhendo MS\r\n\\(U^{Apple}_0 = v^{Apple}_0 + x_0 \\times N^{Apple}\\), escolhendo Apple\r\nTipo 1\r\n\\(U^{MS}_1 = v^{MS}_1 + x_1 \\times N^{MS}\\), escolhendo MS\r\n\\(U^{Apple}_1 = v^{Apple}_1 + x_1 \\times N^{Apple}\\), escolhendo Apple\r\nCom isso, quando um agente precisa escolher qual produto comprar, MS ou Apple, ele simplesmente compara as utilidades:\r\nTipo 0\r\nEscolhe MS se \\(U_0^{MS} > U_0^{Apple}\\)\r\nEscolhe Apple se \\(U_0^{MS} < U_0^{Apple}\\)\r\nTipo 1\r\nEscolhe MS se \\(U_1^{MS} > U_1^{Apple}\\)\r\nEscolhe Apple se \\(U_1^{MS} < U_1^{Apple}\\)\r\n\r\nO modelo funciona da seguinte maneira:\r\nCrie aleatoriamente, com 50% de probabilidade para cada, um agente do tipo 0 ou 1.\r\nCompute suas utilidades ao escolher MS ou Apple.\r\nEscolha, para esse novo agente, o produto com a maior utilidade.\r\nAtualize o \\(N^{MS}\\) caso o agente escolha MS ou o \\(N^{Apple}\\) caso ele escolha Apple.\r\nEquações\r\nA equações requeridas para rodar o modelo derivam dos itens apontados acima (sobre como o modelo funciona), sendo necessário, todavia, uma equação (tanto para utilidade, quanto para número consumidores e sua consequente participação de mercado) para cada tipo de produto. O modelo inteiro é constituido, assim, por 7 equações:\r\n\r\n//#define EIGENLIB          // uncomment to use Eigen linear algebra library\r\n//#define NO_POINTER_INIT   // uncomment to disable pointer checking\r\n#include \"fun_head_fast.h\"\r\n// do not add Equations in this area\r\nMODELBEGIN\r\n// insert your equations here, between the MODELBEGIN and MODELEND words\r\n\r\nEQUATION(\"NewAgent\")\r\n/*\r\nType of new agent\r\n*/\r\nif(RND < 0.5)\r\n    v[0] = 1;\r\nelse\r\n    v[0] = 0;\r\nRESULT(v[0])\r\n\r\n\r\nEQUATION(\"UtilityMS\")\r\n/*\r\nUtility in using MS\r\n*/\r\nv[0] = V(\"NewAgent\"); // type of new agent\r\nif(v[0] == 0)\r\n    {\r\n    v[1] = V(\"User0MS\"); // value for agent type 0 using MS\r\n    v[2] = V(\"User0Net\"); // network externalitie coefficiente for agent type 0\r\n    }\r\nelse\r\n    {\r\n    v[1] = V(\"User1MS\"); // value for agent type 1 using MS\r\n    v[2] = V(\"User1Net\"); // network externalitie coefficiente for agent type 1\r\n    }\r\nv[3] = VL(\"NumMS\", 1); // number of existing consumers using MS\r\nv[4] = v[1] + (v[2] * v[3])\r\nRESULT(v[4])\r\n\r\n\r\nEQUATION(\"UtilityApple\")\r\n/*\r\nUtility in using Apple\r\n*/\r\nv[0] = V(\"NewAgent\"); // type of new agent\r\nif(v[0] == 0)\r\n    {\r\n    v[1] = V(\"User0Apple\"); // value for agent type 0 using Apple\r\n    v[2] = V(\"User0Net\"); // network externalitie coefficiente for agent type 0\r\n    }\r\nelse\r\n    {\r\n    v[1] = V(\"User1Apple\"); // value for agent type 1 using Apple\r\n    v[2] = V(\"User1Net\"); // network externalitie coefficiente for agent type 1\r\n    }\r\nv[3] = VL(\"NumApple\", 1); // number of existing consumers using Apple\r\nv[4] = v[1] + (v[2] * v[3])\r\nRESULT(v[4])\r\n\r\n\r\nEQUATION(\"NumMS\")\r\n/*\r\nNumber of MS users\r\n*/\r\nv[0] = VL(\"NumMS\", 1);\r\nv[1] = V(\"UtilityApple\");\r\nv[2] = V(\"UtilityMS\");\r\nif(v[2] > v[1])\r\n    v[3] = v[0] + 1;\r\nelse\r\n    v[3] = v[0];\r\nRESULT(v[3])\r\n\r\n\r\nEQUATION(\"NumApple\")\r\n/*\r\nNumber of Apple users\r\n*/\r\nv[0] = VL(\"NumApple\", 1);\r\nv[1] = V(\"UtilityApple\");\r\nv[2] = V(\"UtilityMS\");\r\nif(v[2] < v[1])\r\n    v[3] = v[0] + 1;\r\nelse\r\n    v[3] = v[0];\r\nRESULT(v[3])\r\n\r\n\r\nEQUATION(\"ShareMS\")\r\n/*\r\nShare of MS users\r\n*/\r\nv[0] = V(\"NumMS\");\r\nv[1] = V(\"NumApple\");\r\nv[2] = v[0] / (v[0] + v[1])\r\nRESULT(v[2])\r\n\r\n\r\nEQUATION(\"ShareApple\")\r\n/*\r\nShare of Apple users\r\n*/\r\nv[0] = V(\"NumMS\");\r\nv[1] = V(\"NumApple\");\r\nv[2] = v[1] / (v[0] + v[1])\r\nRESULT(v[2])\r\n\r\n\r\nMODELEND\r\n// do not add Equations in this area\r\nvoid close_sim( void )\r\n{\r\n    // close simulation special commands go here\r\n}\r\n\r\nVamos analisar cada um dessas equações com mais detalhes. Lembrando que os modelos escritos no LSD são compostos por um conjunto de Equações que são atualizadas em cada período de uma simulação. Essas equações descrevem o comportamento das variáveis que fazem parte do modelo.\r\nEQUATION(“NewAgent”)\r\nA primeira equação do modelo (lembrando que no LSD a ordem das equações não importa) é bem simples e serve para decidir, com probabilidade de 50%, o tipo de agente, tipo 0 ou tipo 1. Em cada período de tempo (da simulação), a variável “NewAgent” assume o valor 0 ou 1, com probabilidade de 50% para cada.\r\n\r\nEQUATION(\"NewAgent\")\r\n/*\r\nType of new agent\r\n*/\r\nif(RND < 0.5)\r\n    v[0] = 1;\r\nelse\r\n    v[0] = 0;\r\nRESULT(v[0])\r\n\r\nPor exemplo, seja uma simulação com 50 períodos, a variável “NewAgent” apresenta o seguinte comportamento:\r\n\r\n\r\n\r\nEQUATION(“UtilityMS”) | EQUATION(“UtilityApple”)\r\nAs proximas duas equações servem para calcular a utilidade de cada produto (MS e Apple). Como mencionado anteriormente, essa utilidade depende das preferências individuais dos consumidores (tipo 0 e tipo 1) e das externalidades de rede, que por sua vez dependem do número de usuários de cada produto. Ou seja, \\(U^{i}_j = v^{i}_j + x_j \\times N^{i}\\), onde \\(i\\) pode ser \\(MS\\) ou \\(Apple\\) e \\(j\\) pode ser 0 ou 1.\r\n\\(v^{i}_j\\) é um parâmetro que pode assumir 4 valores, a depender do tipo de consumidor e do tipo de produto.\r\n\\(x_j\\) é um parâmetro que pode assumir 2 valores, a depender do tipo de consumidor.\r\n\\(N^{i}\\) é uma variável que conta a quandidade de consumidores de cda tipo de produto.\r\nNo código abaixo, que calcula a utilidade de MS em cada período (seja o novo consumidor sendo do tipo 0 sendo do tipo 1), \\(v^{MS}_0\\) é representado pelo parâmetro “User0MS” e \\(x_0\\) é representado por “User0Net”. O mesmo ocorre para oa parâmetros do consumidor tipo 1.\r\n\r\nEQUATION(\"UtilityMS\")\r\n/*\r\nUtility in using MS\r\n*/\r\nv[0] = V(\"NewAgent\"); // type of new agent\r\nif(v[0] == 0)\r\n    {\r\n    v[1] = V(\"User0MS\"); // value for agent type 0 using MS\r\n    v[2] = V(\"User0Net\"); // network externalitie coefficiente for agent type 0\r\n    }\r\nelse\r\n    {\r\n    v[1] = V(\"User1MS\"); // value for agent type 1 using MS\r\n    v[2] = V(\"User1Net\"); // network externalitie coefficiente for agent type 1\r\n    }\r\nv[3] = VL(\"NumMS\", 1); // number of existing consumers using MS\r\nv[4] = v[1] + (v[2] * v[3])\r\nRESULT(v[4])\r\n\r\nPor exemplo, digamos que os parâmetros sejam escolhidos com os seguintes valores:\r\n\\(v^{MS}_0 = 10\\)\r\n\\(v^{MS}_1 = 5\\)\r\n\\(v^{Apple}_0 = 5\\)\r\n\\(v^{Apple}_1 = 10\\)\r\nOu seja, consumidores tipo 0 dão 5 de utilidade para MS e 10 para Apple, e consumidores tipo 1 fazem o contrário, dão 10 de utilidade para MS e 5 para Apple. Além disso, digamos que tanto \\(x_0\\) quanto \\(x_1\\) possuam um valor de \\(0.2\\), ou seja, essa é a influência que cada número adicional de consumidores possui sobre a externalidade de rede tanto para consumidores do tipo 0 quanto para do tipo 1. Vejamo a evolução das variáveis “UtilityMS” e “UtilityApple”, conforme novos agentes vão aparecendo e escolhendo entre um produto e outro.\r\n\r\nt\r\nNewAgent\r\nUtilityApple\r\nUtilityMS\r\n1\r\n0\r\n5.0\r\n10.0\r\n2\r\n0\r\n5.0\r\n10.2\r\n3\r\n1\r\n10.0\r\n5.4\r\n4\r\n0\r\n5.2\r\n10.4\r\n5\r\n1\r\n10.2\r\n5.6\r\n6\r\n1\r\n10.4\r\n5.6\r\n7\r\n1\r\n10.6\r\n5.6\r\n8\r\n0\r\n5.8\r\n10.6\r\n9\r\n0\r\n5.8\r\n10.8\r\n10\r\n0\r\n5.8\r\n11.0\r\n\r\nComo visto na tabela, o primeiro agente foi do tipo 0, que atribui utilidade 10 para MS e 5 para Apple. Como 10 > 5, esse agente escolhe MS. O segundo agente também é do tipo 0 e atribui 10 para MS e 5 para Apple, porém como já há 1 consumidor utilizando MS, e a externalidade de rede é \\(x \\times N = 0.2 \\times 1 = 0.2\\), a utilidade total de MS é 10.2. O terceiro agente é do tipo 1, que atribui 5 para MS e 10 para Apple. Nesse terceiro períoro já há 2 agentes utilizando MS, portanto a utilidade de MS é acrescida de 0.4. De toda forma, porém, 10 > 5.4, e esse agente escolhe Apple. No longo prazo essas variáveis evoluem da seguinte forma:\r\n\r\n\r\n\r\nÉ possívle observar que após um certo período (em torno de \\(t=250\\)) a utilidade de apple sempre será maior que a de MS, independente do tipo de agente que entrará em seguida. Isso por que a externalidade de rede ultrapassa a diferença de preferências próprias entre os tipos de agentes. A partir desse ponto, todo novo agente irá escolher Apple, o que faz com que o número de usuários desse produto cresça continuamente, enquanto o número de usuários MS permaneça constante (a sua curva de utilidade irá alternar entre os valores 10 e 5 acrescidos da externalidade derivada do número de agentes que escolheram MS até o ponto em que a utilidade MS ultrapassava a de Apple a depender do tipo do agente).\r\nEQUATION(“NumMS”) | EQUATION(“NumApple”)\r\nA equação do número de usuários de cada produto simplemente compara os valores das utilidades de MS e Apple, calculadas nas equações mostradas anteriormente, e aumenta em uma unidade o valor do número de usuários a depender de qual utilidade é maior.\r\n\r\nEQUATION(\"NumMS\")\r\n/*\r\nNumber of MS users\r\n*/\r\nv[0] = VL(\"NumMS\", 1);\r\nv[1] = V(\"UtilityApple\");\r\nv[2] = V(\"UtilityMS\");\r\nif(v[2] > v[1])\r\n    v[3] = v[0] + 1;\r\nelse\r\n    v[3] = v[0];\r\nRESULT(v[3])\r\n\r\nA sua evolução é semelhante à da utilidade, dadas que ambas incrementam quando há uma adição de um agente nesse produto em específico. Recapitulando, em cada período surge um novo agente que deve escolher entre MS e Apple; para fazer tal escolha, esse agente compara as utilidades desses dois tipos de produtos. Além disso, há dois tipos de agentes, que atribuem valores diferentes para sua preferência individual entre MS e Apple. Assim, em cada período, cada novo agente computa as utilidades dos dois produtos — a partir da sua preferência individual e da externalidade de rede, que depende do número de usuários em cada produto — e escolhe o produto com maior utilidade. Com isso, vai aumentando o número de usuários de cada produto.\r\n\r\n\r\n\r\nEQUATION(“ShareMS”) | EQUATION(“ShareApple”)\r\nPor fim, é computado também o market share dos dois tipos de produtos, o que é feito apenas dividindo o número de usuários de cada produto pelo número total de agentes.\r\n\r\nEQUATION(\"ShareMS\")\r\n/*\r\nShare of MS users\r\n*/\r\nv[0] = V(\"NumMS\");\r\nv[1] = V(\"NumApple\");\r\nv[2] = v[0] / (v[0] + v[1])\r\nRESULT(v[2])\r\n\r\n\r\n\r\n\r\nConclusão\r\nEsse modelo explora a dinâmica de um mercado com dois produtos em competição, onde cada usuário adicional de um dos produtos aumenta a externalidade de rede desse produto. Como visto, após certo período o mercado é dominado por um dos tipos de produto e todo usuário novo passa a escolher esse produto, bloqueado — locking out — o outro. Para entender melhor o modelo, foi muito útil analisar as equações de forma separada, buscando observar os inputs que cada equação recebe (parâmetros e outras variáveis) e os outputs que ela retorna em cada período de tempo (os possíveis valores da variável em questão).\r\n\r\n\r\n\r\nARTHUR, W. B. Competing technologies, increasing returns, and lock-in by historical events. The economic journal, v. 99, n. 394, p. 116–131, 1989.\r\n\r\n\r\n\r\n\r\n",
    "preview": "posts/2021-02-09-externrede/externrede_files/figure-html5/unnamed-chunk-11-1.png",
    "last_modified": "2021-03-27T23:03:26-03:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "posts/2021-01-12-eqestoc/",
    "title": "Equações em Diferença Estocásticas",
    "description": "Este Post discute Equações em Diferença Estocásticas.",
    "author": [
      {
        "name": "Rafael Peixoto",
        "url": {}
      }
    ],
    "date": "2021-01-13",
    "categories": [
      "Introdução",
      "Matemática"
    ],
    "contents": "\r\n\r\nContents\r\nIntrodução\r\nEquação homogênea\r\nEquação não-homogênea\r\nConclusão\r\n\r\n\r\n\r\nd-article p {\r\n  text-align: justify;\r\n  font-size: 16px;\r\n}\r\n\r\nd-article p code {\r\n  background: rgba(236, 236, 236, 0.8);\r\n}\r\n\r\nIntrodução\r\nEquações em diferença estocásticas, como o nome deixa claro, são equações em difereça que possuem algum componente estocástico. É comum encontrá-las em modelos de séries temporais, como, por exemplo, ruído branco \\(x_t = \\epsilon_t\\) ou passeio aleatório \\(x_t = x_{t-1} + \\epsilon_t\\).\r\n\r\n\r\n\r\n\r\n\r\n\r\nO ruído branco é um processo com média zero e variância constante. No caso do gráfico, está sendo utilizado uma ruído branco com distribuição normal e variância igual a um. O passeio aleatório é uma equação em diferença de primeira ordem não-homogênea, \\(x_t - \\theta x_{t-1} = f(t)\\), onde o termo \\(f(t)\\) é um processo de ruído branco e o termo \\(\\theta\\) é igual a um. Caso \\(\\theta > 1\\) ou \\(\\theta < -1\\), a equação explode. Caso \\(-1 < \\theta < 1\\), a equação oscila em torno de um valor. Caso o termo \\(f(t)\\) seja composto por um ruído branco mais uma constante, ou seja \\(f(t) = \\epsilon_t + c\\), a equação apresenta uma um drift.\r\n\r\n\r\n\r\nSeja uma equação em diferença de primeira ordem não-homogênea\r\n\\[\r\nx_t - \\theta x_{t-1} = f(t)\r\n\\] A solução geral irá consistir na soma de dois componentes:\r\na solução particular \\(x_p\\), que é qualquer solução da equação não-homogênea\r\na função complementar \\(x_c\\), que é a solução geral da equação reduzida (homogênea) \\(x_t - \\theta x_{t-1} = 0\\)\r\nEquação homogênea\r\nA equação em diferença homogênea de primeira ordem \\(x_t - \\theta x_{t-1} = 0\\) possui a seguinte solução:\r\n\\[\r\n\\begin{aligned}\r\nx_t = C(\\theta)^t\r\n\\end{aligned}\r\n\\]\r\nEm que:\r\n\\(\\theta > 1\\): solução explosiva, não oscilatória.\r\n\\(0 < \\theta < 1\\): solução convergente, não oscilatória.\r\n\\(-1 < \\theta < 0\\): solução convergente, oscilatória.\r\n\\(\\theta < -1\\): solução explosiva, oscilatória.\r\nCaso \\(\\theta\\) seja uma variável estocástica, é possível que ela apresente diferentes valores ao longo do tempo, fazendo com que o comportamento da equação varie ao longo do tempo, conforme o valor de \\(\\theta\\).\r\n\r\n\r\n\r\n\r\n\r\n\r\nEquação não-homogênea\r\nPara resolver uma equação não-homogênea, \\(x_t - \\theta x_{t-1} = f(t)\\), é preciso achar a solução particular e depois somá-la com a função complementar da equação homogênea. Para tanto, é possível escolher qualquer solução da equação.\r\nComo visto, o passeio aleatório, \\(x_t = x_{t-1} + \\epsilon_t\\), é uma equação em diferença de primeira ordem não-homogênea em que \\(\\theta = 1\\). Caso haja drift, \\(f(t) = \\epsilon_t + c\\).\r\nAssim como foi feito para a equação homogêna, vejamos o comportamento da equação não-homogênea para diferentes \\(\\theta\\):\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nAssim como nas equações homogêneas, nas não-homogêneas:\r\n\\(\\theta < 0\\) faz a equação oscilar\r\n\\(|\\theta| > 1\\) faz a equação explodir.\r\nO drift afeta mais os valores da série (os pontos de convergência) gerada pela equação quando \\(\\theta > 0\\) pois esses deslocamentos se reinforçam, ao contrário do que ocorre quando \\(\\theta < 0\\). Mas, de toda forma, o drift não muda o comportamento da equação (oscilatória ou não, convergente ou divergente). Além disso, esse comportamento não depende do valor inicial \\(x_0\\), a menos que esse coincida com o ponto fixo da equação.\r\nConclusão\r\nA equação em diferença \\(x_t - \\theta x_{t-1} = f(t)\\) tem seu comportamento determinado principalmente por \\(\\theta\\), independentemente de \\(f(t)\\) apresentar componentes estocásticos ou não.\r\nEquação Estocástica App\r\nUtilize o aplicativo abaixo para experimentar diferentes configurações da equação de primeira ordem.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nREGINATTO, V. O. Equações a diferenças. Disponível em: <https://www.modelodomundo.com/2019/03/equa>.\r\n\r\n\r\n\r\n\r\n",
    "preview": "posts/2021-01-12-eqestoc/eqestoc_files/figure-html5/unnamed-chunk-2-1.png",
    "last_modified": "2021-03-27T23:04:43-03:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "posts/2021-01-12-segordem/",
    "title": "Equações de Segunda Ordem",
    "description": "Este Post discute Equações em Diferença de Segunda Ordem.",
    "author": [
      {
        "name": "Rafael Peixoto",
        "url": {}
      }
    ],
    "date": "2021-01-12",
    "categories": [
      "Introdução",
      "Matemática"
    ],
    "contents": "\r\n\r\nContents\r\nIntrodução\r\nEquação homogênea\r\nEquação não-homogênea\r\nConclusão\r\n\r\n\r\n\r\nd-article p {\r\n  text-align: justify;\r\n  font-size: 16px;\r\n}\r\n\r\nd-article p code {\r\n  background: rgba(236, 236, 236, 0.8);\r\n}\r\n\r\nIntrodução\r\nUma equação em diferença de segunda ordem é uma equação que envolve a expressão \\(\\Delta ^2 x_t\\), chamada de segunda diferença de \\(x_t\\), mas que não contém diferenças de ordem maior que \\(2\\). O símbolo \\(\\Delta ^2\\) é uma instrução de que está se tomando a segunda diferença:\r\n\\[\r\n\\begin{aligned}\r\n& \\Delta ^2 x_t \r\n\\begin{aligned}\r\n& = \\Delta (\\Delta x_t) \\\\\r\n& = \\Delta (x_t - x_{t-1}) \\\\\r\n& = (x_t - x_{t-1}) - (x_{t-1} - x_{t-2}) \\\\\r\n& = x_t -2x_{t-1} + x_{t-2}\r\n\\end{aligned}\r\n\\end{aligned}\r\n\\]\r\nAssim, a segunda diferença de \\(x_t\\) é transformável em uma soma de termos envolvendo uma diferença de dois períodos de tempo.\r\nDe forma geral, uma equação de segunda ordem pode ser expressa por:\r\n\\[\r\n\\begin{aligned}\r\n& ax_t + bx_{t-1} + cx_{t-2} = f(t)\r\n\\end{aligned}\r\n\\]\r\nEquação homogênea\r\nAssim como para equações de primeira ordem, é possível separar equações de segunda ordem em função complementar e solução particular. Vamos começar pela função complementar, que é a solução geral da equação homogênea.\r\nSeja a equação homogênea:\r\n\\[\r\n\\begin{aligned}\r\n& ax_t + bx_{t-1} + cx_{t-2} = 0\r\n\\end{aligned}\r\n\\] ou, de forma equivalente:\r\n\\[\r\n\\begin{aligned}\r\n& ax_{t+2} + bx_{t+1} + cx_t = 0\r\n\\end{aligned}\r\n\\]\r\nPara encontrar a função complementar de uma equação de segunda ordem, utiliza-se o seguinte articífio:\r\n\\[\r\n\\begin{aligned}\r\n& x_t = \\lambda ^t \\\\\r\n& x_{t+1} = \\lambda ^{t+1} = \\lambda ^t \\lambda \\\\\r\n& x_{t+2} = \\lambda ^{t+2} = \\lambda ^t \\lambda ^2 \\\\[10pt]\r\n& a \\lambda ^2 \\lambda ^t + b \\lambda \\lambda ^t + c \\lambda ^t = 0 \\\\\r\n& \\lambda ^t (a \\lambda ^2 + b \\lambda + c ) = 0 \\\\\r\n& a \\lambda ^2 + b \\lambda + c  = 0\r\n\\end{aligned}\r\n\\]\r\n\\(a \\lambda ^2 + b \\lambda + c = 0\\) também é chamada de equação característica. Como é uma equação de segundo grau, seu \\(\\Delta\\) pode apresentar \\(3\\) resultados possíveis: pode ser negativo, pode ser zero, pode ser positivo. Caso seja positivo, basta utilizar as duas soluções encontradas. Caso seja zero (o que apresenta apenas uma solução \\(x_t\\)), a segunda solução toma a forma de \\(tx_t\\). Caso seja negativo, é necessário calcular a parte imaginária.\r\nExemplo 1: Seja a equação \\(2x_{t+2} - 5x_{t+1} + 2x_t = 0\\). A equação característica é:\r\n\\[\r\n\\begin{aligned}\r\n& 2 \\lambda ^2 - 5 \\lambda + 2 = 0 \\\\[10pt]\r\n& \\Delta = (-5)^2 - 4(2)(2) = 25 - 16 = 9 \\\\\r\n& \\lambda = \\frac{5 \\pm 3}{4} \\\\\r\n& \\begin{cases}\r\n\\lambda_1 = 2 \\\\\r\n\\lambda_2 = \\frac{1}{2}\r\n\\end{cases}\r\n\\end{aligned}\r\n\\]\r\nPortanto, a solução da equação homogênea é:\r\n\\[\r\n\\begin{aligned}\r\n& x_t = \\lambda ^t \\\\[10pt]\r\n& \\begin{cases}\r\nx_t = (2)^t \\\\\r\nx_t = (\\frac{1}{2})^t\r\n\\end{cases} \\\\[10pt]\r\n& x_t = A(2)^t + B(\\frac{1}{2})^t\r\n\\end{aligned}\r\n\\]\r\nDado que as condições iniciais sejam, por exemplo:\r\n\\[\r\n\\begin{aligned}\r\n& \\begin{cases}\r\nx_0 = 2 \\\\\r\nx_1 = \\frac{11}{2}\r\n\\end{cases} \\\\[10pt]\r\n& x_0 = A(2)^0 + B(\\frac{1}{2})^0 = A + B = 2 \\\\\r\n& x_1 = A(2)^1 + B(\\frac{1}{2})^1 = 2A + \\frac{1}{2}B = \\frac{11}{2} \\\\[10pt]\r\n& \\begin{cases}\r\nA + B = 2 \\\\\r\n4A + B = 11 \r\n\\end{cases} \\\\[10pt]\r\n& A = 3; \\quad B= -1 \\\\[10pt]\r\n\\end{aligned}\r\n\\]\r\nA solução final fica:\r\n\\[\r\n\\begin{aligned}\r\n& x_t = 3(2)^t -(\\frac{1}{2})^t\r\n\\end{aligned}\r\n\\]\r\nComo a solução possui um \\(\\lambda > 1\\), a equação apresentará um comportamento explosivo, de forma semelhante a equações de primeira ordem com \\(\\theta >1\\). Vejamos um grafico da sua dinâmica:\r\n\r\n\r\n\r\nEquação não-homogênea\r\nAssim como para equações de primeira ordem, a equação não-homogênea de segunda ordem tem como solução a soma da função complementar e da solução particular, e pode ser expressa genericamente por:\r\n\\[\r\n\\begin{aligned}\r\n& ax_t + bx_{t-1} + cx_{t-2} = f(t)\r\n\\end{aligned}\r\n\\]\r\nExemplo 2: Seja a equação \\(x_{t+2} - 2x_{t+1} +x_t = 2\\). A Equação homogênea seria \\(x_{t+2} - 2x_{t+1} +x_t = 0\\), com equação característica \\(\\lambda^2 - 2\\lambda + 1 = 0\\). Vamos achar a função complementar:\r\n\\[\r\n\\begin{aligned}\r\n& \\Delta = (-2)^2 -4(1)(1) = 0 \\\\\r\n& \\lambda = \\frac{2 \\pm \\sqrt{0}}{(2)(1)} = 1 \\\\[10pt]\r\n& x_t = A(1)^t + Bt(1)^t \\\\\r\n& x_t = A + Bt\r\n\\end{aligned}\r\n\\]\r\nAchada a solução da equação homogênea, o próximo passo é encontrar a solução particular da não-homogênea. Como os três primeiros casos de solução de não-homogênea (\\(x_t = A\\), \\(x_t = At\\) e \\(x_t = A + Bt\\)) não são adequados (eles já são solução da equação homogênea), parte-se para o caso \\(x_t = At^2\\):\r\n\\[\r\n\\begin{aligned}\r\n& x_t = At^2 \\\\\r\n& x_{t+1} = A(t+1)^2 = At^2 + 2At + A \\\\\r\n& x_{t+2} = A(t+2)^2 = At^2 + 4At + 4A \\\\[10pt]\r\n& x_{t+2} - 2x_{t+1} +x_t = 2 \\\\\r\n& At^2 + 4At + 4A - 2At^2 - 4At - 2A + At^2 = 2 \\\\\r\n& 2A = 2 \\\\\r\n& A = 1 \\\\[10pt]\r\n& x_t = At^2 \\\\\r\n& x_t = t^2\r\n\\end{aligned}\r\n\\]\r\nCom isso, a solução geral da equação, que é a soma da função complementar e da solução particular, fica:\r\n\\[\r\n\\begin{aligned}\r\n& x_t = A + Bt + t^2\r\n\\end{aligned}\r\n\\]\r\nDado que as condições iniciais sejam, por exemplo:\r\n\\[\r\n\\begin{aligned}\r\n& \\begin{cases}\r\nx_0 = 1 \\\\\r\nx_1 = 3\r\n\\end{cases} \\\\[10pt]\r\n& x_0 = A + B(0) + 0^2 = A = 1 \\\\\r\n& x_1 = A + B(1) + 1^2 = 2 + B = 3 \\\\[10pt]\r\n& A = 1; \\quad B = 1 \\\\\r\n\\end{aligned}\r\n\\]\r\nA solução final fica:\r\n\\[\r\n\\begin{aligned}\r\n& x_t = 1 + t + t^2\r\n\\end{aligned}\r\n\\]\r\nConclusão\r\nAssim como para equações em diferença de primeira ordem, as equações de segunda ordem também possuem uma solução que é a soma da função complementar com a solução particular:\r\n\\[\r\n\\begin{aligned}\r\n& x_t = x_c + x_p \\\\\r\n\\end{aligned}\r\n\\]\r\nPorém, a função complementar irá chegar na equação característica, que segue a forma:\r\n\\[\r\n\\begin{aligned}\r\n& a \\lambda ^2 + b \\lambda + c  = 0\r\n\\end{aligned}\r\n\\]\r\n\r\n\r\n\r\nNEUSSER, K. Difference equations for economists. Unpublished manuscript, October, v. 3, 2016.\r\n\r\n\r\nSARTORIS, A. Equações a diferenças de 2a ordem. Disponível em: <https://www.youtube.com/watch?v=Q4Bj6XJtcz4>.\r\n\r\n\r\nWAINWRIGHT, K.; CHIANG, A. C. Fundamental methods of mathematical economics. [s.l.] Boston, Mass.: McGraw-Hill/Irwin, 2005.\r\n\r\n\r\n\r\n\r\n",
    "preview": "posts/2021-01-12-segordem/segordem_files/figure-html5/unnamed-chunk-2-1.png",
    "last_modified": "2021-03-27T23:04:12-03:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "posts/2021-01-06-primordem/",
    "title": "Equações de Primeira Ordem",
    "description": "Este Post discute Equações em Diferença de Primeira Ordem.",
    "author": [
      {
        "name": "Rafael Peixoto",
        "url": {}
      }
    ],
    "date": "2021-01-11",
    "categories": [
      "Introdução",
      "Matemática"
    ],
    "contents": "\r\n\r\nContents\r\nIntrodução\r\nSolução\r\nMétodo Iterativo\r\nMétodo Geral\r\n\r\nAplicações\r\nModelo da Teia de Aranha\r\nModelo de Harrod\r\n\r\nConclusão\r\n\r\n\r\n\r\nd-article p {\r\n  text-align: justify;\r\n  font-size: 16px;\r\n}\r\n\r\nd-article p code {\r\n  background: rgba(236, 236, 236, 0.8);\r\n}\r\n\r\nIntrodução\r\nEm contextos em que o tempo é tomado como uma variável discreta — ou seja, a variável \\(t\\) só pode assumir valores inteiros —, o padrão de mudança de uma variável \\(x\\) deve ser descrito pelas chamadas equações em diferença, ao invés de por equações diferenciais ou derivativas.\r\nComo \\(t\\) só pode assumit valores inteiros, quando se compara valores de \\(x\\) em dois períodos consecutivos, tem-se que \\(\\Delta t = 1\\), portanto, o padrão de mudança \\(\\frac{\\Delta x}{\\Delta t}\\) pode ser simplificado para \\(\\Delta x\\). essa é a primeira diferença de \\(x\\). Adicionando-se o subscrito referente ao periodo em que ocorre a mudança \\(\\Delta x\\), tem-se:\r\n\\[\r\n\\Delta x_t \\equiv x_t - x_{t-1}\r\n\\]\r\nAssim, padrões de mudança como \\(\\Delta x_t = 2\\) podem ser expresas como\r\n\\[\r\n\\begin{aligned}\r\n& x_t - x_{t-1} = 2 \\\\\r\n& x_t = x_{t-1} + 2\r\n\\end{aligned}\r\n\\]\r\nEquações em Diferença podem ser:\r\nlinear ou não-linear\r\nhomogênea ou não-homogênea\r\nde primeira ordem ou ordem maior\r\nEsse texto visa analisar apenas equações de primeira ordem, ou seja, equações que envolvem apenas uma diferença de um período. Portanto, salvo indicação, toda vez que em que aparecer o termo equação, este estará se referindo a equações em diferenças de primeira ordem.\r\nUm exemplo de equação de primeira ordem linear e não-homogênea é a seguinte equação afim:\r\n\\[\r\nx_t = \\theta x_{t-1} + z_t, \\qquad \\theta \\ne 0\r\n\\]\r\nA equação homogênea correspondente seria\r\n\\[\r\nx_t = \\theta x_{t-1}\r\n\\]\r\nSolução\r\nA trajetória no tempo, de uma equação em diferença, deve ser uma função de \\(t\\) — uma fórmula definindo os valores de \\(x\\) em cada período de tempo — consistente com a dada equação e com as condições iniciais.\r\nMétodo Iterativo\r\nAntes de apresentar um método geral de solução de equações em diferença, é interessante discutir o método iterativo, que, embora rústico, ajuda a entender a natureza das soluções desse tipo de equação.\r\nEquações de primeira ordem descrevem o padrão de mudança de \\(x\\) entre dois períodos consecutivos. Uma vez que esse padrão é especificado — e.g. \\(\\Delta x_t = 2\\) —, e uma vez que é dado um valor inicial \\(x_0\\), não é problema encontrar \\(x_1\\) com a equação. De forma semelhante, uma vez encontrado \\(x_1\\), é possível obter \\(x_2\\), e assim por diante, iterando o madrão de mudança especificado pela equação em diferença.\r\nExemplo 1: Seja a equação em diferença \\(\\Delta x_t = 2\\), assumindo um valor inicial \\(x_0 = 15\\). É possível inferir a trajetória da variável \\(x\\) iterando a equação, a partir do valor inivial dado.\r\n\\[\r\n\\begin{aligned}\r\n& \\Delta x_t = 2 \\\\\r\n& x_t - x_{t-1} = 2 \\\\\r\n& x_t = x_{t-1} + 2 \\\\\r\n& x_1 = x_0 + 2 \\\\\r\n& x_2 = x_1 + 2 = (x_0 + 2) + 2 = x_0 + 2(2) \\\\\r\n& x_3 = x_2 + 2 = [x_0 + 2(2)] + 2 = x_0 + 3(2) \\\\\r\n& \\dots\r\n\\end{aligned}\r\n\\]\r\nEm geral, para qualquer período \\(t\\):\r\n\\[\r\nx_t = x_0 + t(2)\r\n\\]\r\nComo foi estabelecido que \\(x_0 = 15\\):\r\n\\[\r\nx_t = 15 + 2t\r\n\\]\r\nExemplo 2: Seja a equação em diferença \\(x_t = 0.9x_{t-1}\\), com um valor inicial não especificado. Por iteração tem-se:\r\n\\[\r\n\\begin{aligned}\r\n& x_1 = 0.9x_0 \\\\\r\n& x_2 = 0.9x_1 = 0.9(0.9x_0) = (0.9)^2x_0 \\\\\r\n& x_3 = 0.9x_2 = 0.9(0.9)^2x_0 = (0.9)^3x_0 \\\\\r\n& \\dots\r\n\\end{aligned}\r\n\\]\r\nEm geral, para qualquer período \\(t\\):\r\n\\[\r\nx_t = (0.9)^tx_0\r\n\\]\r\nExemplo 3: Seja a equação em diferença \\(x_t = 2x_{t-1}\\). Por iteração, tem-se:\r\n\\[\r\n\\begin{aligned}\r\n& x_1 = 2x_0 \\\\\r\n& x_2 = 2x_1 = 2(2x_0) = (2)^2x_0 \\\\\r\n& x_3 = 2x_2 = 2(2)^2x_0 = (2)^3x_0 \\\\\r\n& \\dots\r\n\\end{aligned}\r\n\\]\r\nEm geral, para qualquer período \\(t\\):\r\n\\[\r\nx_t = (2)^tx_0\r\n\\]\r\nExemplo 4: Seja a equação em diferença \\(x_t = -4x_{t-1}\\). Por iteração, tem-se:\r\n\\[\r\n\\begin{aligned}\r\n& x_1 = -4x_0 \\\\\r\n& x_2 = -4x_1 = -4(-4x_0) = (-4)^2x_0 \\\\\r\n& x_3 = -4x_2 = -4(-4)^2x_0 = (-4)^3x_0 \\\\\r\n& \\dots\r\n\\end{aligned}\r\n\\]\r\nEm geral, para qualquer período \\(t\\):\r\n\\[\r\nx_t = (-4)^tx_0\r\n\\]\r\nExemplo 5: Seja a equação em diferença \\(x_t = -\\frac{1}{2}x_{t-1}\\). Por iteração, tem-se:\r\n\\[\r\n\\begin{aligned}\r\n& x_1 = -\\frac{1}{2}x_0 \\\\\r\n& x_2 = -\\frac{1}{2}x_1 = -\\frac{1}{2}(-\\frac{1}{2}x_0) = (-\\frac{1}{2})^2x_0 \\\\\r\n& x_3 = -\\frac{1}{2}x_2 = -\\frac{1}{2}(-\\frac{1}{2})^2x_0 = (-\\frac{1}{2})^3x_0 \\\\\r\n& \\dots\r\n\\end{aligned}\r\n\\]\r\nEm geral, para qualquer período \\(t\\):\r\n\\[\r\nx_t = (-\\frac{1}{2})^tx_0\r\n\\]\r\nMétodo Geral\r\nSeja uma equação em diferença de primeira ordem não-homogênea\r\n\\[\r\nx_t - \\theta x_{t-1} = f(t)\r\n\\] A solução geral irá consistir na soma de dois componentes:\r\na solução particular \\(x_p\\), que é qualquer solução da equação não-homogênea\r\na função complementar \\(x_c\\), que é a solução geral da equação reduzida (homogênea) \\(x_t - \\theta x_{t-1} = 0\\)\r\nO componente \\(x_p\\) representa nível de equilíbrio intertemporal de \\(x\\), e o componente \\(x_c\\) representa os desvios da trajetória desse equilíbrio. A soma dos dois constitui a solução geral devido à presença de uma constante arbitrária. Para definir a solução, é necessário um condição inicial.\r\nFunção Complementar\r\nOs exemplos 2 a 5 mostraram a aplicação do método iterativo em equações homogêneas. Essas equações possuem a forma geral\r\n\\[\r\nx_t - \\theta x_{t-1} = 0\r\n\\]\r\nou\r\n\\[\r\nx_t = \\theta x_{t-1}\r\n\\]\r\nComo visto, em todos esses exemplos, a solução encontrada tomou a forma\r\n\\[\r\nx_t = (\\theta)^tx_0\r\n\\]\r\nComo \\(x_0\\) é uma constante, essa solução também aparece como\r\n\\[\r\n\\begin{aligned}\r\n\\boxed{x_t = C(\\theta)^t}\r\n\\end{aligned}\r\n\\]\r\n\r\np.s. \\(C\\) só é igual a \\(x_0\\) em equações homogêneas. O mesmo não vale para equações não-homogêneas\r\nAlém disso, os exemplos demonstraram quatro casos possíveis para esse tipo de equações:\r\n\\(\\theta > 1\\): solução explosiva, não oscilatória.\r\n\\(0 < \\theta < 1\\): solução convergente, não oscilatória.\r\n\\(-1 < \\theta < 0\\): solução convergente, oscilatória.\r\n\\(\\theta < -1\\): solução explosiva, oscilatória.\r\nSolução Particular\r\nComo mencionado acima, para \\(x_p\\) é possível escolher qualquer solução da equação. Assim, uma estratégia muito utilizada é partir da forma mais simples possível e ir adicionando elementos conforme a solução nao se mostre adequada. De forma mais concreta, usualmente segue-se a seguinte ordem:\r\n\\(x_t = A\\)\r\n\\(x_t = At\\)\r\n\\(x_t = At + B\\)\r\nCaso 1: Seja a equação não-homogênea \\(x_t - 0.5x_{t-1} = 2\\). A equação reduzida seria \\(x_t = 0.5x_{t-1}\\), e sua função complementar \\(x_t = C(0.5)^t\\). A solução particular da não-homogênea seria:\r\n\\[\r\n\\begin{aligned}\r\n& x_t = A \\\\\r\n& x_{t-1} = A \\\\[10pt]\r\n& x_t - 0.5x_{t-1} = 2 \\\\\r\n& A - 0.5A = 2 \\\\\r\n& A = 4\r\n\\end{aligned}\r\n\\]\r\nA solução geral seria:\r\n\\[\r\n\\begin{aligned}\r\n& x_t = x_c + x_p \\\\\r\n& x_t = C(\\theta)^t + A \\\\\r\n& x_t = C(0.5)^t + 4\r\n\\end{aligned}\r\n\\]\r\nCaso, por exemplo, a condição inicial seja \\(x_0 = 3\\):\r\n\\[\r\n\\begin{aligned}\r\n& x_0 = C(0.5)^0 + 4 = 3 \\\\\r\n& C = 3 - 4 \\\\\r\n& C = -1 \\\\[10pt]\r\n& x_t = -1(0.5)^t + 4 \\\\\r\n& x_t = 4 - (0.5)^t\r\n\\end{aligned}\r\n\\]\r\nCaso 2: Seja a equação não-homogênea \\(x_t - x_{t-1} = 3\\). A equação reduzida seria \\(x_t = x_{t-1}\\), e sua função complementar \\(x_t = C(1)^t = C\\). A solução particular da não-homogênea seria:\r\n\\[\r\n\\begin{aligned}\r\n& x_t = A \\\\\r\n& x_{t-1} = A \\\\[10pt]\r\n& x_t - x_{t-1} = 3 \\\\\r\n& A - A = 3 \\\\\r\n& 0A = 3\r\n\\end{aligned}\r\n\\]\r\nEssa solução particular não é adequada, portanto parte-se para o segundo caso.\r\n\\[\r\n\\begin{aligned}\r\n& x_t = At \\\\\r\n& x_{t-1} = A(t-1) \\\\[10pt]\r\n& x_t - x_{t-1} = 3 \\\\\r\n& At - (At - A) = 3 \\\\\r\n& At - At + A = 3 \\\\\r\n& A = 3\r\n\\end{aligned}\r\n\\]\r\nA solução geral seria\r\n\\[\r\n\\begin{aligned}\r\n& x_t = x_c + x_p \\\\\r\n& x_t = C(\\theta)^t + At \\\\\r\n& x_t = C + 3t\r\n\\end{aligned}\r\n\\]\r\nCaso, por exemplo, a condição inicial seja \\(x_0 = 5\\):\r\n\\[\r\n\\begin{aligned}\r\n& x_0 = C + 3(0) = 5 \\\\\r\n& C = 5 \\\\[10pt]\r\n& x_t = C + 3t \\\\\r\n& x_t = 5 + 3t\r\n\\end{aligned}\r\n\\]\r\nCaso 3: Seja a equação não-homogênea \\(x_t + 2x_{t-1} = t\\). A equação reduzida seria \\(x_t = -2x_{t-1}\\), e sua função complementar \\(x_t = C(-2)^t\\). A solução particular da não-homogênea seria:\r\n\\[\r\n\\begin{aligned}\r\n& x_t = At \\\\\r\n& x_{t-1} = A(t-1) \\\\[10pt]\r\n& x_t + 2x_{t-1} = t \\\\\r\n& At + 2(At - A) = t \\\\\r\n& At + 2At - 2A = t \\\\\r\n& 3At - 2A = t + 0 \\\\\r\n& \\begin{cases}\r\n  3A = 1 \\\\\r\n  -2A = 0\r\n  \\end{cases}\r\n\\end{aligned}\r\n\\]\r\nEssa solução particular não é adequada, portanto parte-se para o terceiro caso.\r\n\\[\r\n\\begin{aligned}\r\n& x_t = At + B\\\\\r\n& x_{t-1} = A(t-1) + B\\\\[10pt]\r\n& x_t + 2x_{t-1} = t \\\\\r\n& At + B + 2(At - A + B) = t \\\\\r\n& At + B +2At - 2A + 2B = t \\\\\r\n& 3At - 2A + 3B = t + 0 \\\\\r\n& \\begin{cases}\r\n  3A = 1 \\\\\r\n  -2A + 3B = 0\r\n  \\end{cases} \\\\\r\n& A = \\frac{1}{3}; \\qquad B = \\frac{2}{9}\r\n\\end{aligned}\r\n\\]\r\nA solução geral seria\r\n\\[\r\n\\begin{aligned}\r\n& x_t = x_c + x_p \\\\\r\n& x_t = C(\\theta)^t + At + B \\\\\r\n& x_t = C(-2)^t + \\frac{1}{3}t + \\frac{2}{9}\r\n\\end{aligned}\r\n\\]\r\nCaso, por exemplo, a condição inicial seja \\(x_0 = \\frac{20}{9}\\):\r\n\\[\r\n\\begin{aligned}\r\n& x_0 = C(-2)^0 + \\frac{1}{3}(0) + \\frac{2}{9} = \\frac{20}{9} \\\\\r\n& C = \\frac{20}{9} - \\frac{2}{9} \\\\\r\n& C = 2 \\\\[10pt]\r\n& x_t = C(-2)^t + \\frac{1}{3}t + \\frac{2}{9} \\\\\r\n& x_t = 2(-2)^t + \\frac{1}{3}t + \\frac{2}{9}\r\n\\end{aligned}\r\n\\]\r\nAplicações\r\nVejamos dois exemplos simples de modelos econômicos que utilizam equações em diferença.\r\nModelo da Teia de Aranha\r\nEsse é um modelo de demanda e oferta que utiliza o tempo discreto, portanto é definido com equações em diferença. Seja as equações de oferta e demanda:\r\n\\[\r\n\\begin{aligned}\r\n\\begin{cases}\r\nQ_t^D = 130 - 20p_t \\\\\r\nQ_t^O = 10 + 10p_{t-1}\r\n\\end{cases}\r\n\\end{aligned}\r\n\\]\r\nO equilíbrio ocorre quando o preço for constante, \\(p_t = p_{t-1} = p\\). Além disso, o equilíbrio ocorre quando a demanda e a oferta se igualam:\r\n\\[\r\n\\begin{aligned}\r\n& Q_t^O = Q_t^D \\\\\r\n& 10 + 10p = 130 -20p \\\\\r\n& 30p = 120 \\\\\r\n& p = 4 \\\\[10pt]\r\n& Q = 10 + 10(4) = 130 - 20(4) \\\\\r\n& Q = 50\r\n\\end{aligned}\r\n\\]\r\nPorém, partindo de uma valor inicial \\(p \\ne 4\\), o modelo não se encontra em equilíbrio, sendo necessário analisar a sua dinâmica. Para tanto, manteremos os subscritos de \\(p\\) nas equações:\r\n\\[\r\n\\begin{aligned}\r\n\\begin{cases}\r\nQ_t^D = 130 - 20p_t \\\\\r\nQ_t^O = 10 + 10p_{t-1}\r\n\\end{cases}\r\n\\end{aligned}\r\n\\]  \r\n\\[\r\n\\begin{aligned}\r\n& Q_t^O = Q_t^D \\\\\r\n& 10 + 10p_{t-1} = 130 -20p_t \\\\\r\n& 20p_t + 10p_{t-1} = 120 \\\\\r\n& p_t + \\frac{1}{2}p_{t-1} = 6\r\n\\end{aligned}\r\n\\]\r\nAo encontrar o equilíbrio, encontrou-se já uma solução particular para a equação não-homogênea. Vamos encontrar agora a função complementar:\r\n\\[\r\n\\begin{aligned}\r\n& p_t + \\frac{1}{2}p_{t-1} = 0 \\\\\r\n& p_t = - \\frac{1}{2}p_{t-1} \\\\[10pt]\r\n& p_t = C(\\theta)^t \\\\\r\n& p_t = C(- \\frac{1}{2})^t\r\n\\end{aligned}\r\n\\]\r\ncomo \\(-1 < \\theta < 0\\), a solução é convergente e oscilatória.\r\nSolução geral (utilizando a solução particular de equilíbrio):\r\n\\[\r\n\\begin{aligned}\r\n& p_t = C(- \\frac{1}{2})^t + 4\r\n\\end{aligned}\r\n\\]\r\nDigamos que a condição inicial é \\(p_0 = 2\\):\r\n\\[\r\n\\begin{aligned}\r\n& p_0 = C(- \\frac{1}{2})^0 + 4 = 2 \\\\\r\n& C = -2 \\\\\r\n\\end{aligned}\r\n\\]\r\nA solução final fica:\r\n\\[\r\n\\begin{aligned}\r\n& p_t = 4 - 2(- \\frac{1}{2})^t \\\\\r\n& p_{t-1} = 4 - 2(- \\frac{1}{2})^{t-1} = 4 + 4(- \\frac{1}{2})^t \\\\[10pt]\r\n& Q_t^D = 130 - 20p_t \\\\\r\n& Q_t^D = 130 - 20[4 - 2(- \\frac{1}{2})^t] \\\\\r\n& Q_t^D = 50 + 40(- \\frac{1}{2})^t \\\\[10pt]\r\n& Q_t^O = 10 + 10p_{t-1} \\\\\r\n& Q_t^O = 10 + 10[4 + 4(- \\frac{1}{2})^t] \\\\\r\n& Q_t^O = 50 + 40(- \\frac{1}{2})^t \\\\\r\n\\end{aligned}\r\n\\]\r\nComo está sendo utilizado a solução particular do equilíbrio, \\(Q_t^O = Q_t^D\\).\r\nComo já mencionado, o equilíbrio ocorre em \\(p = 4\\), com \\(Q^O = Q^D = 50\\), e a solução é convergente e oscilatória. Vejamos essa dinâmica em gráficos:\r\n\r\n\r\n\r\n\r\n\r\n\r\nModelo de Harrod\r\nEsse é um modelo macroeconômico que relaciona poupança, investimento e crescimento.\r\nA poupança é uma parcela da renda passada, e é dada pela função:\r\n\\[\r\n\\begin{aligned}\r\n& S_t = sY_{t-1}\r\n\\end{aligned}\r\n\\]\r\nO investimento é proporcional ao aumento da renda, e é dado pela função:\r\n\\[\r\n\\begin{aligned}\r\n& I_t = k(Y_t - Y_{t-1})\r\n\\end{aligned}\r\n\\]\r\nO modelo parte do pressuposto de que o investimento é igual a poupança:\r\n\\[\r\n\\begin{aligned}\r\n& S_t =  I_t \\\\\r\n& sY_{t-1} = k(Y_t - Y_{t-1}) \\\\\r\n& kY_t - (k + s)Y_{t-1} = 0 \\\\\r\n& Y_t = \\frac{k + s}{k}Y_{t-1}\r\n\\end{aligned}\r\n\\]\r\nEssa é uma equação em diferença homogênea. Como \\(\\theta = \\frac{k + s}{k}\\) só pode ser positivo e maior que \\(1\\), a solução é não oscilatória e divergente. Portanto, não há uma renda de equilíbrio, e essa cresce indefinidamente.\r\nDigamos que \\(k\\) e \\(s\\) sejam tais que:\r\n\\[\r\n\\begin{aligned}\r\n& S_t =  0.25Y_{t-1} \\\\\r\n& I_t = 0.5(Y_t - Y_{t-1}) \\\\[10pt]\r\n& Y_t = \\frac{0.5 + 0.25}{0.5}Y_{t-1} \\\\\r\n& Y_t = \\frac{3}{2}Y_{t-1} \\\\\r\n\\end{aligned}\r\n\\]\r\nVejamos essa dinâmica no gráfico:\r\n\r\n\r\n\r\nConclusão\r\nComo visto, a solução geral de uma equação em diferença de primeira ordem é\r\n\\[\r\n\\begin{aligned}\r\n& x_t = x_c + x_p \\\\\r\n\\end{aligned}\r\n\\]\r\nEm que\r\n\\[\r\n\\begin{aligned}\r\n& x_c = C(\\theta)^t \\\\\r\n\\end{aligned}\r\n\\]\r\nSendo que\r\n\\(\\theta > 1\\): solução explosiva, não oscilatória.\r\n\\(0 < \\theta < 1\\): solução convergente, não oscilatória.\r\n\\(-1 < \\theta < 0\\): solução convergente, oscilatória.\r\n\\(\\theta < -1\\): solução explosiva, oscilatória.\r\nE\r\n\\[\r\n\\begin{aligned}\r\n& x_p =  \r\n\\begin{cases}\r\nA \\\\\r\nAt \\\\\r\nAt + B\r\n\\end{cases}\\\\\r\n\\end{aligned}\r\n\\]\r\nPrimeira Ordem App\r\nUtilize o aplicativo abaixo para experimentar diferentes configurações da equação de primeira ordem.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nNEUSSER, K. Difference equations for economists. Unpublished manuscript, October, v. 3, 2016.\r\n\r\n\r\nSARTORIS, A. Equação a diferenças de 1a ordem, não homogênea. Disponível em: <https://www.youtube.com/watch?v=YVZKn3ANUbc>.\r\n\r\n\r\n___. Aplicações de equações a diferenças de 1a ordem. Disponível em: <https://www.youtube.com/watch?v=KqKDOBtoeU4>.\r\n\r\n\r\nWAINWRIGHT, K.; CHIANG, A. C. Fundamental methods of mathematical economics. [s.l.] Boston, Mass.: McGraw-Hill/Irwin, 2005.\r\n\r\n\r\n\r\n\r\n",
    "preview": "posts/2021-01-06-primordem/primordem_files/figure-html5/unnamed-chunk-2-1.png",
    "last_modified": "2021-03-27T23:05:14-03:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "posts/2020-12-31-eqdiff/",
    "title": "Equações em Diferença",
    "description": "Este Post apresenta uma introdução ao estudo de Equações em Diferença.",
    "author": [
      {
        "name": "Rafael Peixoto",
        "url": {}
      }
    ],
    "date": "2021-01-06",
    "categories": [
      "Introdução",
      "Matemática"
    ],
    "contents": "\r\n\r\nContents\r\nDefinição\r\nHomogeneidade\r\nSolução\r\nEstabilidade\r\nConclusão\r\n\r\n\r\n\r\nd-article p {\r\n  text-align: justify;\r\n}\r\n\r\nDefinição\r\nA equação em diferença descreve a evolução de alguma variável (ou grupo de variáveis) ao longo do tempo. O valor dessa variável no período \\(t\\) é denotado por \\(x_t\\). O índice de tempo \\(t\\) assume valores discretos e tipicamente abrange todos os números inteiros, ou seja, \\(t = \\dots, -2, -1, 0, 1, 2, \\dots\\).\r\nUma equação em diferença, então, nada mais é que uma regra uma função que indica como computar o valor da variável de interesse no próximo período, e.g. \\(t+1\\), dado seu valor presente, \\(t\\), ou passado, e.g. \\(t-1\\). Em sua forma mais geral, uma equação em diferença pode ser ecrita como:\r\n\\[\r\nF(x_{t+1}, x_t, x_{t-1}, \\dots, x_{t-p+1}, t) = 0\r\n\\]\r\nOnde \\(F\\) é uma função dada.\r\nHomogeneidade\r\nSe o tempo não aparece como um argumento separado e entra somente como um índice da variável, a equação é dita autônoma ou homogênea. No caso de equações de primeira ordem, por exemplo, a forma geral é \\[\\theta_1 x_t + \\theta_0x_{t-1} = g(t)\\] A equação homogênea seria\r\n\\[\\theta_1 x_t + \\theta_0x_{t-1} = 0\\]\r\nEscrita de outra forma:\r\n\\[x_{t} = f(x_{t-1})\\]\r\nSolução\r\nA partir disso, dado algum valor inicial para \\(x\\) no período \\(0\\), a equação em diferença determina, unicamente, todos os valores subsequentes de \\(x_t\\), com \\(t=1,2,\\dots\\), inserindo os valores de \\(x_t\\) iterativamente na equação. No caso da equação de primeira ordem homogênea, como apontada acima:\r\n\\[\r\n\\begin{align}\r\n& x_0 = x \\\\\r\n& x_1 = f(x_0) = f(x) \\\\\r\n& x_2 = f(x_1) = f(f(x)) = f^2(x) \\\\\r\n& \\dots \\\\\r\n& x_t = f(x_{t-1}) = f^t(x)\r\n\\end{align}\r\n\\]\r\nAssim, o valor da variável \\(x\\) no período \\(t\\) é uma função do seu valor inicial. Para explicitar essa dependência, escreve-se \\(x_t = \\phi(t,x)\\). Como resultado dessa iteração, a equação em diferença gera uma sequência, em \\(t = 0, 1, 2, \\dots\\), chamada de trajetória. O conjunto de valores realizados por uma trajetória particular é chamada de órbita.\r\n\r\n\r\n\r\nPara selecionar uma solução única para a equação em diferença, requerimentos adicionais são necessários, como as condições de fronteira. No exemplo acima, foi fornecido um valor inicial para a variável, o que o enquadra em uma condição de valor inicial. Se as condições de fronteira são suficientes para fixar uma única solução, o modelo (baseado em equações em diferença) é dito determinado.\r\nEstabilidade\r\nUsualmente, não é de interesse apenas umas descrição da evolução da variável dependente ao longo do tempo, mas também algumas propriedades qualitativas das soluções. Em particular, é importante caracterizar o comportamento de longo-prazo, ou assimptótico, da variável.\r\nUm ponto fixo de uma função \\(f\\) é um número \\(x^*\\) que quando aplicado na função resulta nele mesmo, ou seja, \\(x^* = f(x^*, t)\\). Posto de outra forma, é um número que não muda quando iterado na função. Assim, a órbita de \\(x^*\\) consiste apenas de \\(x^*\\).\r\nUm ponto fixo é estável, ou atrator, se pontos pertos dele convergem para o ponto fixo quando são iterados. Por outro lado, um ponto fixo é instável, ou repulsor, se pontos perto dele divergem do ponto fixo quando são iterados.\r\nExemplo 1: seja a equação em diferença \\(x_t = x_{t-1}^2\\). A função \\(f(x) = x^2\\) apresenta dois pontos fixos: \\(0\\) e \\(1\\). O que é fácil de se verificar: \\[\r\n\\begin{align}\r\n& x = f(x) \\\\\r\n& x = x^2 \\\\\r\n& x - x^2 = 0 \\\\\r\n& x(1 - x) = 0 \\\\\r\n& x = 0 ; \\ x = 1\r\n\\end{align}\r\n\\]\r\nO gráfico abaixo mostra quatro iterações da equação \\(x_t = x_{t-1}^2\\), para \\(x_0\\) igual a 0; 1; 1.1; -1.2; 0.9.\r\n\r\n\r\n\r\nÉ possível observar que \\(x\\) se mantém constante para \\(x_0 = 0\\) e \\(x_0 = 1\\). Além disso, para valores de \\(x_0\\) entre \\(0\\) e \\(1\\), como \\(0.9\\), \\(x\\) tende ao ponto fixo \\(0\\); e para valores fora desse intervalo \\(x\\) tente ao infinito. Considerando apenas números positivos, é possivel afirmar que \\(x = 0\\) é um ponto fixo estável, pois conforme se escolhe um \\(x_0\\) cada vez mais longe de \\(0\\), \\(x\\) sempre irá tender a \\(0\\), até que se chegue em \\(x_0 = 1\\). A partir daí, conforme se escolhe um \\(x_0\\) maior que \\(1\\), \\(x\\) tenderá sempre a se afastar desse ponto fixo, portanto \\(x = 1\\) é um ponto fixo instável.\r\n\r\n\r\n\r\n\r\nExemplo 2: seja a equação em diferença \\(x_t = \\frac{1}{2}x_{t-1} - 4\\). A função \\(f(x) = \\frac{1}{2}x - 4\\) apresenta quais pontos fixos?\r\n\\[\r\n\\begin{align}\r\n& x = f(x) \\\\\r\n& x = \\frac{1}{2}x - 4 \\\\\r\n& \\frac{1}{2}x = -4 \\\\\r\n& x = -8 \\\\\r\n\\end{align}\r\n\\]\r\nVejamos no gráfico:\r\n\r\n\r\n\r\nÉ possível observar que \\(x\\) se mantém constante para \\(x_0 = -8\\). Além disso, para valores de \\(x_0\\) tanto maiores quanto menores a \\(-8\\), \\(x\\) tende ao ponto fixo \\(-8\\). Portanto, este é um ponto fixo estável.\r\n\r\n\r\n\r\n\r\nExemplo 3: seja a Equação Logística \\(x_t = m \\times x_{t-1} \\times (1 - x_{t-1})\\). A função \\(f(x) = m \\times x \\times (1 - x)\\) apresenta quais pontos fixos?\r\n\\[\r\n\\begin{align}\r\n& x = f(x) \\\\\r\n& x = mx(1 - x) \\\\\r\n& mx(1 - x) - x = 0 \\\\\r\n& x(m - mx - 1) = 0 \\\\\r\n& x = 0 ; \\ x = 1 - \\frac{1}{m} \\\\\r\n\\end{align}\r\n\\]\r\nVejamos o gráfico para m = 2:\r\n\r\n\r\n\r\nÉ possível observar que \\(x\\) se mantém constante para \\(x_0 = 0\\) e \\(x_0 = 0.5\\). Além disso, para valores de \\(x_0\\) tanto maiores quanto menores a \\(0.5\\), \\(x\\) tende ao ponto fixo \\(0.5\\). Portanto, este é um ponto fixo estável.Já \\(x_0 = 0\\) é um ponto fixo instável, pois conforme \\(x\\) se afasta dele, até \\(x = 0.5\\), mais ele tende a se afastar, em direção àqele ponto fixo. Fora do intervalo \\([0,1]\\) a equação explode.\r\n\r\n\r\n\r\n\r\nVejamos o gráfico para m = 3:\r\n\r\n\r\n\r\nÉ possível observar que \\(x\\) se mantém constante para \\(x_0 = 0\\) e \\(x_0 = 0.666\\). Além disso, para valores de \\(x_0\\) tanto maiores quanto menores a \\(0.666\\), \\(x\\) tende a oscilar entre esse ponto. Como visto acima, esses são os pontos fixos da equação:\r\n\\[\r\n\\begin{align}\r\n& x = 0 ; \\ x = 1 - \\frac{1}{m} \\\\\r\n\\end{align}\r\n\\]\r\nPara \\(m = 3\\), o segundo ponto fixo é \\(1 - \\frac{1}{3}\\), aproximadamente \\(0.666\\). Para valores de \\(x_0\\) diferentes dos dois pontos fixos, a iteração da equação gera um ciclo atrator, a óbita é periódica. Diferentes valores de \\(m\\), entre \\(3\\) e \\(4\\) (excluso), geram ciclos atratores com diferentes períodos (número de interações para se repetir um ciclo).\r\nVejamos o gráfico para m = 4:\r\n\r\n\r\n\r\nÉ possível observar que \\(x\\) se mantém constante para \\(x_0 = 0\\) e \\(x_0 = 0.75\\) (segundo ponto fixo). Já para os valores de \\(x_0\\) tanto maiores quanto menores a \\(0.75\\), \\(x\\) tende a oscilar de forma aperiódica, ou seja, a óbita é aperiódica.\r\nApesar de a Equação Logística ser determinística, como as órbitas são aperiódicas para \\(m = 4\\), variações pequenas no \\(x_0\\) levam a trajetórias completamente distintas, o que torna impraticável a previsão de \\(x\\) após um certo número de iterações. Tal comportamento é denominado de dependência sensível das condições iniciais (sensitive dependence on initial conditions (SDIC)). Posto de outra forma, um sistema dinâmico possui dependência sensível das condições iniciais se diferenças arbitrariamente pequenas nas condições iniciais eventualmente levam a diferenças arbitrariamente grandes nas órbitas.\r\nEsse comportamento é bem visível quando se parte de \\(x_0\\) muito próximos:\r\n\r\n\r\n\r\nAté o período \\(14\\), as órbitas se comportam de forma muito semelhante, mas as diferenças vão se acumulando a cada iteração, fazendo com que a partir deste período as órbitas se divirjam enormemente. Caso isso fosse um exercício de previsão, um ‘erro’ de \\(0.00001\\) no valor inicial faria com que essa previsão fosse errônea a partir do período \\(14\\). Esse comportamento é denominado também de efeito borboleta.\r\nLogistic App\r\nUtilize o aplicativo abaixo para experimentar diferentes configurações da equação logística.\r\n\r\n\r\n\r\n\r\nConclusão\r\nEssa breve introdução buscou apresentar o conceito de equações em diferença e algumas de suas características principais. O foco se deu sobre o comportamento ao longo do tempo desse tipo de equação. Como visto, a órbita produzida por uma sequência de iterações de uma equação em diferença pode apresentar diversos comportamentos:\r\nPonto fixo\r\nAtraído por um ponto fixo\r\nExplosivo\r\nCiclo periódico\r\nCiclo aperiódico\r\nEsses comportamentos dependem tanto da estrutura da equação em si como do valor inicial \\(x_0\\).\r\n\r\n\r\n\r\nNEUSSER, K. Difference equations for economists. Unpublished manuscript, October, v. 3, 2016.\r\n\r\n\r\nWAINWRIGHT, K.; CHIANG, A. C. Fundamental methods of mathematical economics. [s.l.] Boston, Mass.: McGraw-Hill/Irwin, 2005.\r\n\r\n\r\n\r\n\r\n",
    "preview": "posts/2020-12-31-eqdiff/eqdiff_files/figure-html5/unnamed-chunk-2-1.png",
    "last_modified": "2021-03-27T23:05:53-03:00",
    "input_file": {},
    "preview_width": 360,
    "preview_height": 193
  }
]
